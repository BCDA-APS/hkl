class ReflectionList
!!!185986.cpp!!!	ReflectionList(in geometry : Geometry, in type : ReflectionType)
    _reflectionFactory = new ReflectionFactory(_geometry, type);
!!!186114.cpp!!!	~ReflectionList()
    delete _reflectionFactory;
    
    vector<Reflection *>::iterator iter = _reflections.begin();
    vector<Reflection *>::iterator end = _reflections.end();
    while(iter != end)
      {
        delete *iter;
        ++iter;
      }
!!!186242.cpp!!!	ReflectionList(in source : ReflectionList)
    _reflectionFactory = new ReflectionFactory(*(source._reflectionFactory));
    
    vector<Reflection *>::const_iterator iter = source._reflections.begin();
    vector<Reflection *>::const_iterator end = source._reflections.end();
    while(iter != end)
      {
        _reflections.push_back((*iter)->clone());
        ++iter;
      }
!!!186370.cpp!!!	clone() : ReflectionList
    return new ReflectionList(*this);
!!!186498.cpp!!!	add(in hkl : svector) : Reflection
    Reflection * reflection = _reflectionFactory->create();
    reflection->set_hkl(hkl);
    
    // When trying to add an active reflection, check that the reflection is not already in.
    // if already in change the flag to false.
    if (reflection->flag())
      {
        vector<Reflection *>::iterator iter = _reflections.begin();
        vector<Reflection *>::iterator end = _reflections.end();
        while(iter != end)
          {
            if (hkl == (*iter)->get_hkl())
              {
                reflection->flag() = false;
              }
            ++iter;
          }
      }
    
    // add the reflection
    _reflections.push_back(reflection);
    
    return *reflection;
!!!186626.cpp!!!	del(in index : uint) : void
    unsigned int nb_reflection = _reflections.size();
    
    if (index >= nb_reflection)
      {
        ostringstream reason;
        ostringstream description;
    
        reason << "Can not delete the reflection : " << index;
        if (nb_reflection)
          description << "Index out of range, the maximum index is : " << nb_reflection-1;
        else
          description << "There is no reflection to delete.";
    
        HKLEXCEPTION(reason.str(), description.str());
      }
    else
      {
        vector<Reflection *>::iterator iter = _reflections.begin();
        for(unsigned int i=0;i<index;i++)
          ++iter;
        delete *iter;
        _reflections.erase(iter);
      }
!!!186754.cpp!!!	size() : uint
    return _reflections.size();
!!!186882.cpp!!!	size_indep() : uint
    unsigned int nb_usable_reflections = 0;
    vector<Reflection *>::const_iterator iter = _reflections.begin();
    vector<Reflection *>::const_iterator iter2 = _reflections.begin();
    vector<Reflection *>::const_iterator end = _reflections.end();
    
    while(iter < end)
      {
        if ((*iter)->flag())
          {
            if (nb_usable_reflections == 0)
              nb_usable_reflections = 1;
            iter2 = iter;
            ++iter2;
            while(iter2 < end)
              {
                if ((*iter2)->flag() && !(*iter)->isColinear(**iter2))
                  nb_usable_reflections++;
                ++iter2;
              }
          }
        ++iter;
      }
    return nb_usable_reflections;
!!!187010.cpp!!!	operator[](in index : uint) : Reflection
    unsigned int nb_reflection = _reflections.size();
    
    if (index >= nb_reflection)
      {
        ostringstream reason;
        ostringstream description;
    
        reason << "Index of the reflection is out of range : " << index;
        if (nb_reflection > 1)
          description << "The maximum index is : " << nb_reflection-1;
        else
          description << "No reflection in the ReflectionList";
    
        HKLEXCEPTION(reason.str(), description.str());
      }
    else
      return _reflections[index];
!!!187138.cpp!!!	begin() : ReflectionList::iterator
    return _reflections.begin();
!!!187266.cpp!!!	end() : ReflectionList::iterator
    return _reflections.end();
!!!187394.cpp!!!	operator==(in reflectionList : ReflectionList) : bool
    if (!(_geometry == reflectionList._geometry))
      return false;
    
    if (_reflections.size() != reflectionList._reflections.size())
      return false;
    else
      {
        vector<Reflection *>::const_iterator iter = _reflections.begin();
        vector<Reflection *>::const_iterator end = _reflections.end();
        vector<Reflection *>::const_iterator iter2 = reflectionList._reflections.begin();
        while(iter != end)
          {
            if (!(**iter == **iter2))
              return false;
            ++iter;
            ++iter2;
          }
      }
    return true;
!!!187522.cpp!!!	printToStream(inout flux : ostream) : ostream
    _geometry.printToStream(flux);
    
    flux << _reflections.size() << " reflection(s)" << endl;
    vector<Reflection *>::const_iterator iter = _reflections.begin();
    vector<Reflection *>::const_iterator end = _reflections.end();
    while(iter != end)
      {
        (*iter)->printToStream(flux);
        flux << endl;
        ++iter;
      }
    return flux;
!!!187650.cpp!!!	toStream(inout flux : ostream) : ostream
    unsigned int nb_reflections = _reflections.size();
    
    flux << nb_reflections << endl;
    for(unsigned int i=0;i<nb_reflections;i++)
      _reflections[i]->toStream(flux);
    return flux;
!!!187778.cpp!!!	fromStream(inout flux : istream) : istream
    unsigned int nb_reflections = _reflections.size();
    if ( nb_reflections )
      {
        vector<Reflection *>::iterator iter = _reflections.begin();
        vector<Reflection *>::iterator end = _reflections.end();
        while(iter != end)
          {
            delete *iter;
          }
        _reflections.clear();
      }
    
    flux >> nb_reflections;
    for(unsigned int i=0; i< nb_reflections; i++)
      {
        Reflection * reflection = _reflectionFactory->create();
        reflection->fromStream(flux);
        _reflections.push_back(reflection);
      }
    return flux;
