class Geometry
!!!167426.cpp!!!	Geometry(in name : string, in description : string, in nb_holder : uint)
  for(unsigned int i=0;i<nb_holder;i++)
    _holders.push_back(new hkl::Holder(_axes));
!!!213250.cpp!!!	~Geometry()
  for(unsigned int i=0;i<_holders.size();i++)
    delete _holders[i];
!!!167682.cpp!!!	Geometry(in geometry : Geometry)
      AxeMap::const_iterator AxeMap_iter = geometry._axes.begin();
      AxeMap::const_iterator AxeMap_end = geometry._axes.end();
      
      // update the _sample and _detector members
      _sample.clear();
      _detector.clear();
      
      AxeList::const_iterator iter = geometry._sample.begin();
      AxeList::const_iterator end = geometry._sample.end();
      while(iter != end)
        {
          MyString const & name = (*iter)->get_name();
          Axe & axe = _axes[name];
          if (AxeMap_iter != AxeMap_end)
            _sample.push_back(&axe);
          ++iter;
        }
      
      iter = geometry._detector.begin();
      end = geometry._detector.end();
      while(iter != end)
        {
          MyString const & name = (*iter)->get_name();
          Axe & axe = _axes[name];
          if (AxeMap_iter != AxeMap_end)
            _detector.push_back(&axe);
          ++iter;
        }
!!!168066.cpp!!!	get_source() : Source
  return _source;
!!!168578.cpp!!!	get_axe(in name : string) : Axe
      return _axes[name];
!!!239362.cpp!!!	get_axe(in name : string) : Axe
        return _axes[name];
!!!168962.cpp!!!	add_sample_axe(inout axe : Axe) : Axe
  _holders[0]->add(axe);
!!!169090.cpp!!!	add_detector_axe(inout axe : Axe, in idx : uint) : Axe
  _holders[1]->add(axe);
!!!169218.cpp!!!	getSampleQuaternion() : Quaternion
      Quaternion q;
      
      AxeList::const_iterator iter = _sample.begin();
      AxeList::const_iterator end = _sample.end();
      while (iter != end)
        {
          q *= (*iter)->asQuaternion();
          ++iter;
        }
      
      return q;
!!!169346.cpp!!!	getSampleRotationMatrix() : smatrix
      return getSampleQuaternion().asMatrix();
!!!169474.cpp!!!	getQ() : svector
      // Attention pour l'instant qf est obtenu a partir de qi
      // il faudrait prendre 1, 0, 0 comme référence.
      Quaternion qr;
      Quaternion const & qi = _source.get_qi();
      
      AxeList::const_iterator iter = _detector.begin();
      AxeList::const_iterator end = _detector.end();
      while (iter != end)
        {
          qr *= (*iter)->asQuaternion();
          ++iter;
        }
      
      Quaternion q(qr);
      q *= qi;
      q *= qr.conjugate();
      q -= qi;
      
      return svector(q.b(), q.c(), q.d());
!!!169602.cpp!!!	getKf() : svector
      // Attention pour l'instant qf est obtenu a partir de qi
      // il faudrait prendre 1, 0, 0 comme référence.
      Quaternion qr;
      Quaternion const & qi = _source.get_qi();
      
      AxeList::const_iterator iter = _detector.begin();
      AxeList::const_iterator end = _detector.end();
      while (iter != end)
        {
          qr *= (*iter)->asQuaternion();
          ++iter;
        }
      
      Quaternion q(qr);
      q *= qi;
      q *= (qr.conjugate());
      
      return svector(q.b(), q.c(), q.d());
!!!169858.cpp!!!	get_distance(in geometry : Geometry) : double
      double distance = 0;
      AxeMap::const_iterator iter1 = _axes.begin();
      AxeMap::const_iterator end = _axes.end();
      AxeMap::const_iterator iter2 = geometry._axes.begin();
      while(iter1 != end)
        {
          distance += iter1->second.getDistance(iter2->second);
          ++iter1;
          ++iter2;
        }
      return distance;
!!!169986.cpp!!!	computeHKL(out h : double, out k : double, out l : double, in UB : smatrix) : void
      smatrix R = getSampleRotationMatrix() * UB;
      
      double det;
      
      det  =  R.get(0,0)*(R.get(1,1)*R.get(2,2)-R.get(2,1)*R.get(1,2));
      det += -R.get(0,1)*(R.get(1,0)*R.get(2,2)-R.get(2,0)*R.get(1,2));
      det +=  R.get(0,2)*(R.get(1,0)*R.get(2,1)-R.get(2,0)*R.get(1,1));
      
      if (fabs(det) < constant::math::epsilon)
        HKLEXCEPTION("det(R) is null",
                     "La matrice rotation de la machine n'est pas valide");
      else
        {
      
          svector q = getQ();
      
          double sum;
      
          sum =   q.x() * (R.get(1,1)*R.get(2,2)-R.get(1,2)*R.get(2,1));
          sum += -q.y() * (R.get(0,1)*R.get(2,2)-R.get(0,2)*R.get(2,1));
          sum +=  q.z() * (R.get(0,1)*R.get(1,2)-R.get(0,2)*R.get(1,1));
          h = sum / det;
      
          sum =  -q.x() * (R.get(1,0)*R.get(2,2)-R.get(1,2)*R.get(2,0));
          sum +=  q.y() * (R.get(0,0)*R.get(2,2)-R.get(0,2)*R.get(2,0));
          sum += -q.z() * (R.get(0,0)*R.get(1,2)-R.get(0,2)*R.get(1,0));
          k = sum / det;
      
          sum =   q.x() * (R.get(1,0)*R.get(2,1)-R.get(1,1)*R.get(2,0));
          sum += -q.y() * (R.get(0,0)*R.get(2,1)-R.get(0,1)*R.get(2,0));
          sum +=  q.z() * (R.get(0,0)*R.get(1,1)-R.get(0,1)*R.get(1,0));
          l = sum / det;
        }
!!!170370.cpp!!!	printToStream(inout flux : ostream) : ostream
      int nb_axes = _sample.size();
      
      flux.precision(3);
      flux << "  Source: " << _source.get_waveLength()
      << ", " << _source.get_direction() << endl;
      //samples
      flux << "  Samples: (" << nb_axes << ")" << endl;
      AxeList::const_iterator it = _sample.begin();
      AxeList::const_iterator end = _sample.end();
      while(it != end)
        {
          Axe const & axe = **it;
          flux.width(12);
          flux << axe.get_name();
          flux << ": " << axe.get_axe();
          flux << "(" << showpos << axe.get_direction() << ")";
          flux.unsetf(ios_base::showpos);
          flux << "  " << axe.get_current().get_value()*constant::math::radToDeg;
          flux << endl;
          ++it;
        }
      
      //detector
      nb_axes = _detector.size();
      flux << "  Detectors: (" << nb_axes << ")" << endl;
      it = _detector.begin();
      end = _detector.end();
      while(it != end)
        {
          Axe const & axe = **it;
          flux.width(12);
          flux << axe.get_name();
          flux << ": " << axe.get_axe();
          flux << "(" << showpos << axe.get_direction() << ")";
          flux.unsetf(ios_base::showpos);
          flux << "  " << axe.get_current().get_value()*constant::math::radToDeg;
          flux << endl;
          ++it;
        }
      
      return flux;
!!!170498.cpp!!!	toStream(inout flux : ostream) : ostream
      HKLObject::toStream(flux);
      _source.toStream(flux);
      _axes.toStream(flux);
      return flux;
!!!170626.cpp!!!	fromStream(inout flux : istream) : istream
      HKLObject::fromStream(flux);
      _source.fromStream(flux);
      _axes.fromStream(flux);
      return flux;
