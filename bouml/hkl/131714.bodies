class Geometry
!!!168066.cpp!!!	get_source() : Source
  return _source;
!!!249730.cpp!!!	get_axes() : AxeList
  return _holders.axes();
!!!249858.cpp!!!	axes() : AxeList
  return _holders.axes();
!!!168578.cpp!!!	get_axe(in name : string) : Axe
  return _holders.axes()[name];
!!!239362.cpp!!!	get_axe(in name : string) : Axe
  return _holders.axes()[name];
!!!262402.cpp!!!	get_sample_quaternion() : Quaternion
      Quaternion q;
      _holders[0]->apply(q);
  
      return q;
!!!262530.cpp!!!	get_sample_quaternion_consign() : Quaternion
      Quaternion q;
      _holders[0]->apply_consign(q);
  
      return q;
!!!262658.cpp!!!	get_sample_rotation_matrix() : smatrix
    return this->get_sample_quaternion().asMatrix();
!!!262786.cpp!!!	get_sample_rotation_matrix_consign() : smatrix
    return this->get_sample_quaternion_consign().asMatrix();
!!!262914.cpp!!!	get_Q() : svector
  // Attention pour l'instant qf est obtenu a partir de qi
  // il faudrait prendre 1, 0, 0 comme référence.
    Quaternion qr;
    Quaternion const & qi = _source.get_qi();

    _holders[1]->apply(qr);

    Quaternion q(qr);
    q *= qi;
    q *= qr.conjugate();
    q -= qi;

    return svector(q.b(), q.c(), q.d());
!!!263042.cpp!!!	get_Q_consign() : svector
  // Attention pour l'instant qf est obtenu a partir de qi
  // il faudrait prendre 1, 0, 0 comme référence.
    Quaternion qr;
    Quaternion const & qi = _source.get_qi();

    _holders[1]->apply_consign(qr);

    Quaternion q(qr);
    q *= qi;
    q *= qr.conjugate();
    q -= qi;

    return svector(q.b(), q.c(), q.d());
!!!263170.cpp!!!	get_kf() : svector
  // Attention pour l'instant qf est obtenu a partir de qi
  // il faudrait prendre 1, 0, 0 comme référence.
    Quaternion qr;
    Quaternion const & qi = _source.get_qi();

    _holders[1]->apply(qr);

    Quaternion q(qr);
    q *= qi;
    q *= (qr.conjugate());

    return svector(q.b(), q.c(), q.d());
!!!263298.cpp!!!	get_kf_consign() : svector
  // Attention pour l'instant qf est obtenu a partir de qi
  // il faudrait prendre 1, 0, 0 comme référence.
    Quaternion qr;
    Quaternion const & qi = _source.get_qi();

    _holders[1]->apply_consign(qr);

    Quaternion q(qr);
    q *= qi;
    q *= (qr.conjugate());

    return svector(q.b(), q.c(), q.d());
!!!169858.cpp!!!	get_distance(in geometry : Geometry) : double
  return _holders.axes().get_distance(geometry._holders.axes());
!!!262274.cpp!!!	get_distance_consign(in geometry : Geometry) : double
    return _holders.axes().get_distance_consign(geometry._holders.axes());
!!!169986.cpp!!!	computeHKL(out h : double, out k : double, out l : double, in UB : smatrix) : void
      smatrix R = this->get_sample_rotation_matrix() * UB;
      
      double det;
      
      det  =  R.get(0,0)*(R.get(1,1)*R.get(2,2)-R.get(2,1)*R.get(1,2));
      det += -R.get(0,1)*(R.get(1,0)*R.get(2,2)-R.get(2,0)*R.get(1,2));
      det +=  R.get(0,2)*(R.get(1,0)*R.get(2,1)-R.get(2,0)*R.get(1,1));
      
      if (fabs(det) < constant::math::epsilon)
        HKLEXCEPTION("det(R) is null",
                     "La matrice rotation de la machine n'est pas valide");
      else
        {
      
          svector q = get_Q();
      
          double sum;
      
          sum =   q.x() * (R.get(1,1)*R.get(2,2)-R.get(1,2)*R.get(2,1));
          sum += -q.y() * (R.get(0,1)*R.get(2,2)-R.get(0,2)*R.get(2,1));
          sum +=  q.z() * (R.get(0,1)*R.get(1,2)-R.get(0,2)*R.get(1,1));
          h = sum / det;
      
          sum =  -q.x() * (R.get(1,0)*R.get(2,2)-R.get(1,2)*R.get(2,0));
          sum +=  q.y() * (R.get(0,0)*R.get(2,2)-R.get(0,2)*R.get(2,0));
          sum += -q.z() * (R.get(0,0)*R.get(1,2)-R.get(0,2)*R.get(1,0));
          k = sum / det;
      
          sum =   q.x() * (R.get(1,0)*R.get(2,1)-R.get(1,1)*R.get(2,0));
          sum += -q.y() * (R.get(0,0)*R.get(2,1)-R.get(0,1)*R.get(2,0));
          sum +=  q.z() * (R.get(0,0)*R.get(1,1)-R.get(0,1)*R.get(1,0));
          l = sum / det;
        }
!!!264578.cpp!!!	operator==(in geometry : Geometry) : bool
        return HKLObject::operator==(geometry)
          && _source == geometry._source
          && _holders == geometry._holders;
!!!170370.cpp!!!	printToStream(inout flux : ostream) : ostream
  HKLObject::printToStream(flux);
  flux << std::endl << _source;
  flux << std::endl << _holders.axes();
    return flux;
!!!170498.cpp!!!	toStream(inout flux : ostream) : ostream
      HKLObject::toStream(flux);
      _source.toStream(flux);
      _holders.toStream(flux);
      return flux;
!!!170626.cpp!!!	fromStream(inout flux : istream) : istream
      HKLObject::fromStream(flux);
      _source.fromStream(flux);
      _holders.fromStream(flux);
      return flux;
