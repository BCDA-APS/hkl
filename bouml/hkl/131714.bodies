class Geometry
!!!167682.cpp!!!	Geometry(in geometry : Geometry)
AxeMap::const_iterator AxeMap_iter = geometry._axes.begin();
AxeMap::const_iterator AxeMap_end = geometry._axes.end();

// update the _sample and _detector members
_sample.clear();
_detector.clear();

AxeList::const_iterator iter = geometry._sample.begin();
AxeList::const_iterator end = geometry._sample.end();
while(iter != end)
  {
    MyString const & name = (*iter)->get_name();
    Axe & axe = _axes[name];
    if (AxeMap_iter != AxeMap_end)
      _sample.push_back(&axe);
    ++iter;
  }

iter = geometry._detector.begin();
end = geometry._detector.end();
while(iter != end)
  {
    MyString const & name = (*iter)->get_name();
    Axe & axe = _axes[name];
    if (AxeMap_iter != AxeMap_end)
      _detector.push_back(&axe);
    ++iter;
  }
!!!167810.cpp!!!	operator=(in geometry : Geometry) : Geometry
HKLObject::operator=(geometry);
_source = geometry._source;

// now make a deep copy of _samples and _detector
_axes = geometry._axes;

// update the _sample and _detector AxeVector
AxeMap::const_iterator AxeMap_iter = geometry._axes.begin();
AxeMap::const_iterator AxeMap_end = geometry._axes.end();

_sample.clear();
_detector.clear();

AxeList::const_iterator iter = geometry._sample.begin();
AxeList::const_iterator end = geometry._sample.end();
while(iter != end)
  {
    MyString const & name = (*iter)->get_name();
    Axe & axe = _axes[name];
    if (AxeMap_iter != AxeMap_end)
      _sample.push_back(&axe);
    ++iter;
  }

iter = geometry._detector.begin();
end = geometry._detector.end();
while(iter != end)
  {
    MyString const & name = (*iter)->get_name();
    Axe & axe = _axes[name];
    if (AxeMap_iter != AxeMap_end)
      _detector.push_back(&axe);
    ++iter;
  }
return *this;
!!!168194.cpp!!!	axes() : AxeMap
return _axes;
!!!168578.cpp!!!	get_axe(in name : string) : Axe
return _axes[name];
!!!168706.cpp!!!	get_axe(in name : string) : Axe
return _axes[name];
!!!168834.cpp!!!	getAxesNames() : vector<string>
vector<string> nameList;

// sample part
AxeList::const_iterator it = _sample.begin();
AxeList::const_iterator end = _sample.end();
while(it != end)
  {
    nameList.push_back((*it)->get_name());
    ++it;
  }

// detector part
it = _detector.begin();
end = _detector.end();
while(it != end)
  {
    nameList.push_back((*it)->get_name());
    ++it;
  }

return nameList;
!!!168962.cpp!!!	addSampleAxe(in axe : Axe) : Axe
string const & name = axe.get_name();

//Est-ce que cet axe est déjà présent dans la liste?
AxeList::iterator sample_iter = _sample.begin();
AxeList::iterator sample_end = _sample.end();
while(sample_iter != sample_end)
  {
    if ((*sample_iter)->get_name() == name)
      {
        ostringstream description;
        description << "The axe \"" << name << "\" is already present in the sample axe list";
        HKLEXCEPTION("Can not add two times the same axe",
                     description.str());
      }
    else
      ++sample_iter;
  }

AxeMap::iterator iter = _axes.find(name);
AxeMap::iterator end = _axes.end();
if (iter == end)
  {
    pair<AxeMap::iterator, bool> res = _axes.insert(AxeMap::value_type(name, axe));
    Axe & stored_axe = res.first->second;
    _sample.push_back(&stored_axe);
    return &stored_axe;
  }
else
  {
    if (iter->second == axe)
      {
        _sample.push_back(&iter->second);
        return &iter->second;
      }
    else
      {
        ostringstream description;
        description << "Same name but different axe." << endl
        << "Axe1 : ";
        iter->second.printToStream(description);
        description << "Axe2 : ";
        axe.printToStream(description);
        HKLEXCEPTION("Can not add this axe \"Axe2\" to the sample axe list",
                     description.str());
      }
  }
!!!169090.cpp!!!	addDetectorAxe(in axe : Axe) : Axe
string const & name = axe.get_name();

//Est-ce que cet axe est deja present dans la liste?
AxeList::iterator detector_iter = _detector.begin();
AxeList::iterator detector_end = _detector.end();
while(detector_iter != detector_end)
  {
    if ((*detector_iter)->get_name() == name)
      {
        ostringstream description;
        description << "The axe \"" << name << "\" is already present in the detector axe list";
        HKLEXCEPTION("Can not add two times the same axe",
                     description.str());
      }
    detector_iter++;
  }

AxeMap::iterator iter = _axes.find(name);
AxeMap::iterator end = _axes.end();
if (iter == end)
  {
    pair<AxeMap::iterator, bool> res = _axes.insert(AxeMap::value_type(name, axe));
    Axe & stored_axe = res.first->second;
    _detector.push_back(&stored_axe);
    return &stored_axe;
  }
else
  {
    if (iter->second == axe)
      {
        _detector.push_back(&iter->second);
        return &iter->second;
      }
    else
      {
        ostringstream description;
        description << "Same name but different axe." << endl
        << "Axe1 : ";
        iter->second.printToStream(description);
        description << "Axe2 : ";
        axe.printToStream(description);
        HKLEXCEPTION("Can not add this axe \"Axe2\" to the detector axe list",
                     description.str());
      }
  }
!!!169218.cpp!!!	getSampleQuaternion() : Quaternion
Quaternion q;

AxeList::const_iterator iter = _sample.begin();
AxeList::const_iterator end = _sample.end();
while (iter != end)
  {
    q *= (*iter)->asQuaternion();
    ++iter;
  }

return q;
!!!169346.cpp!!!	getSampleRotationMatrix() : smatrix
return getSampleQuaternion().asMatrix();
!!!169474.cpp!!!	getQ() : svector
// Attention pour l'instant qf est obtenu a partir de qi
// il faudrait prendre 1, 0, 0 comme référence.
Quaternion qr;
Quaternion const & qi = _source.get_qi();

AxeList::const_iterator iter = _detector.begin();
AxeList::const_iterator end = _detector.end();
while (iter != end)
  {
    qr *= (*iter)->asQuaternion();
    ++iter;
  }

Quaternion q(qr);
q *= qi;
q *= qr.conjugate();
q -= qi;

return svector(q.b(), q.c(), q.d());
!!!169602.cpp!!!	getKf() : svector
// Attention pour l'instant qf est obtenu a partir de qi
// il faudrait prendre 1, 0, 0 comme référence.
Quaternion qr;
Quaternion const & qi = _source.get_qi();

AxeList::const_iterator iter = _detector.begin();
AxeList::const_iterator end = _detector.end();
while (iter != end)
  {
    qr *= (*iter)->asQuaternion();
    ++iter;
  }

Quaternion q(qr);
q *= qi;
q *= (qr.conjugate());

return svector(q.b(), q.c(), q.d());
!!!169858.cpp!!!	getDistance(in geometry : Geometry) : double
double distance = 0;
AxeMap::const_iterator iter1 = _axes.begin();
AxeMap::const_iterator end = _axes.end();
AxeMap::const_iterator iter2 = geometry._axes.begin();
while(iter1 != end)
  {
    distance += iter1->second.getDistance(iter2->second);
    ++iter1;
    ++iter2;
  }
return distance;
!!!169986.cpp!!!	computeHKL(out h : double, out k : double, out l : double, in UB : smatrix) : void
smatrix R = getSampleRotationMatrix() * UB;

double det;

det  =  R.get(0,0)*(R.get(1,1)*R.get(2,2)-R.get(2,1)*R.get(1,2));
det += -R.get(0,1)*(R.get(1,0)*R.get(2,2)-R.get(2,0)*R.get(1,2));
det +=  R.get(0,2)*(R.get(1,0)*R.get(2,1)-R.get(2,0)*R.get(1,1));

if (fabs(det) < constant::math::epsilon)
  HKLEXCEPTION("det(R) is null",
               "La matrice rotation de la machine n'est pas valide");
else
  {

    svector q = getQ();

    double sum;

    sum =   q.x() * (R.get(1,1)*R.get(2,2)-R.get(1,2)*R.get(2,1));
    sum += -q.y() * (R.get(0,1)*R.get(2,2)-R.get(0,2)*R.get(2,1));
    sum +=  q.z() * (R.get(0,1)*R.get(1,2)-R.get(0,2)*R.get(1,1));
    h = sum / det;

    sum =  -q.x() * (R.get(1,0)*R.get(2,2)-R.get(1,2)*R.get(2,0));
    sum +=  q.y() * (R.get(0,0)*R.get(2,2)-R.get(0,2)*R.get(2,0));
    sum += -q.z() * (R.get(0,0)*R.get(1,2)-R.get(0,2)*R.get(1,0));
    k = sum / det;

    sum =   q.x() * (R.get(1,0)*R.get(2,1)-R.get(1,1)*R.get(2,0));
    sum += -q.y() * (R.get(0,0)*R.get(2,1)-R.get(0,1)*R.get(2,0));
    sum +=  q.z() * (R.get(0,0)*R.get(1,1)-R.get(0,1)*R.get(1,0));
    l = sum / det;
  }
!!!170242.cpp!!!	operator==(in geometry : Geometry) : bool
return HKLObject::operator==(geometry)
       && _source == geometry._source
       && _axes == geometry._axes;
!!!170370.cpp!!!	printToStream(inout flux : ostream) : ostream
int nb_axes = _sample.size();

flux.precision(3);
flux << "  Source: " << _source.get_waveLength()
<< ", " << _source.get_direction() << endl;
//samples
flux << "  Samples: (" << nb_axes << ")" << endl;
AxeList::const_iterator it = _sample.begin();
AxeList::const_iterator end = _sample.end();
while(it != end)
  {
    Axe const & axe = **it;
    flux.width(12);
    flux << axe.get_name();
    flux << ": " << axe.get_axe();
    flux << "(" << showpos << axe.get_direction() << ")";
    flux.unsetf(ios_base::showpos);
    flux << "  " << axe.get_current().get_value()*constant::math::radToDeg;
    flux << endl;
    ++it;
  }

//detector
nb_axes = _detector.size();
flux << "  Detectors: (" << nb_axes << ")" << endl;
it = _detector.begin();
end = _detector.end();
while(it != end)
  {
    Axe const & axe = **it;
    flux.width(12);
    flux << axe.get_name();
    flux << ": " << axe.get_axe();
    flux << "(" << showpos << axe.get_direction() << ")";
    flux.unsetf(ios_base::showpos);
    flux << "  " << axe.get_current().get_value()*constant::math::radToDeg;
    flux << endl;
    ++it;
  }

return flux;
!!!170498.cpp!!!	toStream(inout flux : ostream) : ostream
HKLObject::toStream(flux);
_source.toStream(flux);
_axes.toStream(flux);
return flux;
!!!170626.cpp!!!	fromStream(inout flux : istream) : istream
HKLObject::fromStream(flux);
_source.fromStream(flux);
_axes.fromStream(flux);
return flux;
