class Geometry
!!!168066.cpp!!!	get_source() : Source
  return _source;
!!!249730.cpp!!!	get_axes() : AxeList
  return _holders.axes();
!!!249858.cpp!!!	axes() : AxeList
  return _holders.axes();
!!!168578.cpp!!!	get_axe(in name : string) : Axe
  return _holders.axes()[name];
!!!239362.cpp!!!	get_axe(in name : string) : Axe
  return _holders.axes()[name];
!!!169218.cpp!!!	getSampleQuaternion() : Quaternion
    Quaternion q;
    _holders[0]->apply(q);

    return q;
!!!169346.cpp!!!	getSampleRotationMatrix() : smatrix
      return getSampleQuaternion().asMatrix();
!!!169474.cpp!!!	getQ() : svector
      // Attention pour l'instant qf est obtenu a partir de qi
      // il faudrait prendre 1, 0, 0 comme référence.
      Quaternion qr;
      Quaternion const & qi = _source.get_qi();
     
      _holders[1]->apply(qr);
      
      Quaternion q(qr);
      q *= qi;
      q *= qr.conjugate();
      q -= qi;
      
      return svector(q.b(), q.c(), q.d());
!!!169602.cpp!!!	getKf() : svector
      // Attention pour l'instant qf est obtenu a partir de qi
      // il faudrait prendre 1, 0, 0 comme référence.
      Quaternion qr;
      Quaternion const & qi = _source.get_qi();
     
      _holders[1]->apply(qr);
      
      Quaternion q(qr);
      q *= qi;
      q *= (qr.conjugate());
      
      return svector(q.b(), q.c(), q.d());
!!!169858.cpp!!!	get_distance(in geometry : Geometry) : double
  return _holders.axes().get_distance(geometry._holders.axes());
!!!169986.cpp!!!	computeHKL(out h : double, out k : double, out l : double, in UB : smatrix) : void
      smatrix R = getSampleRotationMatrix() * UB;
      
      double det;
      
      det  =  R.get(0,0)*(R.get(1,1)*R.get(2,2)-R.get(2,1)*R.get(1,2));
      det += -R.get(0,1)*(R.get(1,0)*R.get(2,2)-R.get(2,0)*R.get(1,2));
      det +=  R.get(0,2)*(R.get(1,0)*R.get(2,1)-R.get(2,0)*R.get(1,1));
      
      if (fabs(det) < constant::math::epsilon)
        HKLEXCEPTION("det(R) is null",
                     "La matrice rotation de la machine n'est pas valide");
      else
        {
      
          svector q = getQ();
      
          double sum;
      
          sum =   q.x() * (R.get(1,1)*R.get(2,2)-R.get(1,2)*R.get(2,1));
          sum += -q.y() * (R.get(0,1)*R.get(2,2)-R.get(0,2)*R.get(2,1));
          sum +=  q.z() * (R.get(0,1)*R.get(1,2)-R.get(0,2)*R.get(1,1));
          h = sum / det;
      
          sum =  -q.x() * (R.get(1,0)*R.get(2,2)-R.get(1,2)*R.get(2,0));
          sum +=  q.y() * (R.get(0,0)*R.get(2,2)-R.get(0,2)*R.get(2,0));
          sum += -q.z() * (R.get(0,0)*R.get(1,2)-R.get(0,2)*R.get(1,0));
          k = sum / det;
      
          sum =   q.x() * (R.get(1,0)*R.get(2,1)-R.get(1,1)*R.get(2,0));
          sum += -q.y() * (R.get(0,0)*R.get(2,1)-R.get(0,1)*R.get(2,0));
          sum +=  q.z() * (R.get(0,0)*R.get(1,1)-R.get(0,1)*R.get(1,0));
          l = sum / det;
        }
!!!170370.cpp!!!	printToStream(inout flux : ostream) : ostream
  /*
      int nb_axes = _sample.size();
      
      flux.precision(3);
      flux << "  Source: " << _source.get_waveLength()
      << ", " << _source.get_direction() << endl;
      //samples
      flux << "  Samples: (" << nb_axes << ")" << endl;
      AxeList::const_iterator it = _sample.begin();
      AxeList::const_iterator end = _sample.end();
      while(it != end)
        {
          Axe const & axe = **it;
          flux.width(12);
          flux << axe.get_name();
          flux << ": " << axe.get_axe();
          flux << "(" << showpos << axe.get_direction() << ")";
          flux.unsetf(ios_base::showpos);
          flux << "  " << axe.get_current().get_value()*constant::math::radToDeg;
          flux << endl;
          ++it;
        }
      
      //detector
      nb_axes = _detector.size();
      flux << "  Detectors: (" << nb_axes << ")" << endl;
      it = _detector.begin();
      end = _detector.end();
      while(it != end)
        {
          Axe const & axe = **it;
          flux.width(12);
          flux << axe.get_name();
          flux << ": " << axe.get_axe();
          flux << "(" << showpos << axe.get_direction() << ")";
          flux.unsetf(ios_base::showpos);
          flux << "  " << axe.get_current().get_value()*constant::math::radToDeg;
          flux << endl;
          ++it;
        }
      
      return flux;
  */
  return flux;
!!!170498.cpp!!!	toStream(inout flux : ostream) : ostream
      HKLObject::toStream(flux);
      _source.toStream(flux);
      _holders.toStream(flux);
      return flux;
!!!170626.cpp!!!	fromStream(inout flux : istream) : istream
      HKLObject::fromStream(flux);
      _source.fromStream(flux);
      _holders.fromStream(flux);
      return flux;
