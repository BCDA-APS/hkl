class Holder
!!!243714.cpp!!!	add_rotation(in name : string, in axe : svector) : Rotation
  return this->add<hkl::axe::Rotation>(new hkl::axe::Rotation(name, "rotation", -1, 0, 1, axe));
!!!245250.cpp!!!	apply(inout q : Quaternion) : Quaternion
  std::vector<hkl::HolderRow>::const_iterator iter = _rows.begin();
  std::vector<hkl::HolderRow>::const_iterator end = _rows.begin();
  while (iter != end)
  {
    iter->axe->apply(q);
    ++iter;
  }

  return q;
!!!245122.cpp!!!	set_axes(inout axeList : AxeList) : void
  _axes = axeList;
  std::vector<hkl::HolderRow>::iterator iter = _rows.begin();
  std::vector<hkl::HolderRow>::iterator end = _rows.end();
  while(iter != end)
  {
    iter->axe = _axes->operator[](iter->idx);
    ++iter;
  }
!!!249986.cpp!!!	operator==(in holder : Holder) : bool
  if(*_axes == *holder._axes)
  {
    if (_rows.size() == holder._rows.size())
    {
      std::vector<hkl::HolderRow>::const_iterator iter = _rows.begin();
      std::vector<hkl::HolderRow>::const_iterator iter2 = holder._rows.begin();
      std::vector<hkl::HolderRow>::const_iterator end = _rows.end();
      while(iter != end)
      {
        if ( iter->idx != iter2->idx)
          return false;
        ++iter;
        ++iter2;
      }
      return true;
    }
  }
  return false;
!!!245890.cpp!!!	printToStream(inout flux : ostream) : ostream
  flux << "holder: (" << _rows.size() << ") Axe List related : " << _axes << std::endl;
  std::vector<hkl::HolderRow>::const_iterator iter = _rows.begin();
  std::vector<hkl::HolderRow>::const_iterator end = _rows.end();
  while(iter != end)
  {
    flux << "  (" << iter->axe << ", " << iter->idx << ") "
         << *(iter->axe) << std::endl;
    ++iter;
  }

  return flux;
!!!249474.cpp!!!	toStream(inout flux : ostream) : ostream
  unsigned int size = _rows.size();
  flux << " " << size;
  for(unsigned int i=0;i<size;i++)
    flux << " " << _rows[i].idx;
  flux << std::endl;
  return flux;
!!!249602.cpp!!!	fromStream(inout flux : istream) : istream
  // read the size of the _row when the holder was save.
  unsigned int size;
  flux >> size;
  // check if size is compatible with the size of the actual holder.
  _rows.clear();
  for(unsigned int i=0;i<size;i++)
  {
    unsigned int idx;
    flux >> idx;
    // now update the row in the Axe Row
    hkl::HolderRow row = {_axes->operator[](idx), idx};
    _rows.push_back(row);
  }
  return flux;
