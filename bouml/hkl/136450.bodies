class Q
!!!206082.cpp!!!	Q(inout geometry : Geometry)
      
      // add all the PseudoAxes
      _q = new PseudoAxe( "q", "domega = 1/2 * d2theta.", this);
      _pseudoAxes.push_back(_q);
      
      // add observer to observable
      _tth->add_observer(this);
      
      // fill the relatedAxes
      _relatedAxes.push_back(_tth);
      
      Q::connect();
      Q::update();
!!!206210.cpp!!!	~Q()
      delete _q;
!!!206466.cpp!!!	update() : void
      if (_connected)
        {
          double lambda = _geometry.get_source().get_waveLength().get_value();

          // compute the min and max of the PseudoAxe
          double min = 2 * constant::physic::tau * sin(_tth->get_min().get_value() / 2.) / lambda;
          double max = 2 * constant::physic::tau * sin(_tth->get_max().get_value() / 2.) / lambda;

          // compute the current and consign values of the PseudoAxe.
          double theta = _tth->get_current().get_value() / 2.;
          double current = 2 * constant::physic::tau * sin(theta) / lambda;

          double theta_c = _tth->get_consign().get_value() / 2.;
          double consign = 2 * constant::physic::tau * sin(theta_c) / lambda;
          this->set_pseudoAxe(_q, min, current, consign, max);

          // no need to compute the writability of the pseudoAxe.
          // As it is always writable.
        }
!!!206594.cpp!!!	set() : void
    double lambda = _geometry.get_source().get_waveLength().get_value();
    double tth = 2 * asin(_q->get_consign().get_value() * lambda / (2 * constant::physic::tau));

    Q::unconnect();
    _tth->set_consign(tth);
    Q::connect();
    Q::update();
!!!206722.cpp!!!	toStream(inout flux : ostream) : ostream
      PseudoAxeEngineTemp<hkl::twoC::vertical::Geometry>::toStream(flux);
      
      return flux;
!!!206850.cpp!!!	fromStream(inout flux : istream) : istream
      PseudoAxeEngineTemp<hkl::twoC::vertical::Geometry>::fromStream(flux);
      
      return flux;
