class Eulerians
!!!208002.cpp!!!	Eulerians(inout geometry : Geometry)
      // parameters
      _solution = new Parameter("solution", "Switch between solution 0 or 1(default)\n",
                                0, 1, 1);
      _parameters.add(_solution);
      
      // add all the PseudoAxes
      _omega = new PseudoAxe("omega", "omega", this);
      _chi = new PseudoAxe("chi", "chi", this);
      _phi = new PseudoAxe("phi", "phi", this);
      _pseudoAxes.push_back(_omega);
      _pseudoAxes.push_back(_chi);
      _pseudoAxes.push_back(_phi);
      
      // add observer to observable
      _komega->add_observer(this);
      _kappa->add_observer(this);
      _kphi->add_observer(this);
      
      // fill relatedAxes
      _relatedAxes.push_back(_komega);
      _relatedAxes.push_back(_kappa);
      _relatedAxes.push_back(_kphi);
      
      this->connect();
      Eulerians::update();
!!!208130.cpp!!!	~Eulerians()
      delete _solution;
      
      delete _omega;
      delete _chi;
      delete _phi;
!!!208258.cpp!!!	initialize() : void
  _initialized = true;
  _writable = true;
!!!208514.cpp!!!	update() : void
      if (_connected)
        {
          // compute the range of all PseudoAxes.
          /*
          // compute the current part
          double const & komega = _komega->get_current().get_value();
          double const & kappa = _kappa->get_current().get_value();
          double const & kphi = _kphi->get_current().get_value();
          double omega, chi, phi;
          hkl::kappa_to_eulerian(komega, kappa, kphi, _alpha, omega, chi, phi, _solution->get_current().get_value());
      
          // compute the consign part
          double const & komega_c = _komega->get_consign().get_value();
          double const & kappa_c = _kappa->get_consign().get_value();
          double const & kphi_c = _kphi->get_consign().get_value();
          double omega_c, chi_c, phi_c;
          hkl::kappa_to_eulerian(komega_c, kappa_c, kphi_c, _alpha, omega_c, chi_c, phi_c, _solution->get_current().get_value());
          */
          hkl::Range omega;
          hkl::Range chi;
          hkl::Range phi;
          hkl::kappa4C::vertical::kappa_to_eulerian(*_komega, *_kappa, *_kphi, _alpha, omega, chi, phi, _solution->get_current().get_value());

          this->set_pseudoAxe(_omega, omega.get_min().get_value(), omega.get_current().get_value(), omega.get_consign().get_value(), omega.get_max().get_value());
          this->set_pseudoAxe(_chi, chi.get_min().get_value(), chi.get_current().get_value(), chi.get_consign().get_value(), chi.get_max().get_value());
          this->set_pseudoAxe(_phi, phi.get_min().get_value(), phi.get_current().get_value(), phi.get_consign().get_value(), phi.get_max().get_value());
        }
!!!208642.cpp!!!	set() : void
    double const & omega_c = _omega->get_consign().get_value();
    double const & chi_c = _chi->get_consign().get_value();
    double const & phi_c = _phi->get_consign().get_value();
    double komega_c, kappa_c, kphi_c;
    hkl::kappa4C::vertical::eulerian_to_kappa(omega_c, chi_c, phi_c, _alpha, komega_c, kappa_c, kphi_c, _solution->get_current().get_value());

    Eulerians::unconnect();
    _komega->set_consign(komega_c);
    _kappa->set_consign(kappa_c);
    _kphi->set_consign(kphi_c);
    Eulerians::connect();
    Eulerians::update();
!!!208770.cpp!!!	toStream(inout flux : ostream) : ostream
      ((hkl::PseudoAxeEngineTemp<hkl::kappa4C::vertical::Geometry> *)this)->toStream(flux);
      _solution->toStream(flux);
      
      return flux;
!!!208898.cpp!!!	fromStream(inout flux : istream) : istream
      ((hkl::PseudoAxeEngineTemp<hkl::kappa4C::vertical::Geometry> *)this)->fromStream(flux);
      _solution->fromStream(flux);
      
      return flux;
