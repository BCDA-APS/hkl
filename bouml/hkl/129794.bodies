class Range
!!!150018.cpp!!!	Range(in min : Value, in current : Value, in consign : Value, in max : Value)
    if (min <= current && current <= max && min <= consign && consign <= max)
      {
        _min = min;
        _current = current;
        _consign = consign;
        _max = max;
      }
    else
      {
        std::ostringstream reason;
        reason << "Can not create such a range " << min << " <= [" << current << ", " << consign << "] <= " << max << std::endl;
        HKLEXCEPTION(reason.str(), "set a valid range");
      }
!!!150274.cpp!!!	set_current(in current : Value) : void
    if (_min <= current && current <= _max)
        _current = current;
    else
      {
        std::ostringstream reason;
        reason << "Can not set this current value : " << current.get_value()
        << " outside (" << _min.get_value() << ":" << _max.get_value() << ")";
        HKLEXCEPTION(reason.str(), "Change the current value or the minimun and maximum range.");
      }
!!!150786.cpp!!!	set_current(in current : double) : void
    _current.set_value(current);
!!!258946.cpp!!!	set_consign(in consign : Value) : void
        if (_min <= consign && consign <= _max)
            _consign = consign;
        else
          {
            std::ostringstream reason;
            reason << "Can not set this consign value : " << consign.get_value()
            << " outside (" << _min.get_value() << ":" << _max.get_value() << ")";
            HKLEXCEPTION(reason.str(), "Change the consign value or the minimun and maximum range.");
          }
!!!150914.cpp!!!	set_range(in min : Value, in max : Value) : void
    if (min <= _current && min <= _consign)
      {
        if (_current <= max && _consign <= max)
        {
            _min = min;
            _max = max;
        }
        else
          {
            std::ostringstream reason;
            reason << "Can not set a maximum (" << max << ") lower than the current value (" << _current << ", " << _consign << ")";
            HKLEXCEPTION(reason.str(), "Change the current value or the minimun range.");
          }
      }
    else
      {
        std::ostringstream reason;
        reason << "Can not set a minimum (" << min << ") greater than the current/consign value (" << _current << ", " << _consign << ")";
        HKLEXCEPTION(reason.str(), "Change the current/consign value before setting the minimun range.");
      }
!!!151042.cpp!!!	set(in min : double, in current : double, in consign : double, in max : double) : void
      _min = min;
      _current = current;
      _consign = consign;
      _max = max;
!!!151170.cpp!!!	set(in range : Range) : void
      _min = range._min;
      _current = range._current;
      _consign = range._consign;
      _max = range._max;
!!!269826.cpp!!!	operator+=(in range : Range) : Range
    _min += range._min;
    _current += range._current;
    _consign += range._consign;
    _max += range._max;

    return *this;
!!!269954.cpp!!!	operator+=(in value : double) : Range
    _min += value;
    _current += value;
    _consign += value;
    _max += value;

    return *this;
!!!151298.cpp!!!	operator*=(in range : Range) : Range
      double m1 = _min.get_value() * range._min.get_value();
      double m2 = _min.get_value() * range._max.get_value();
      double m3 = _max.get_value() * range._min.get_value();
      double m4 = _max.get_value() * range._max.get_value();
      
      double min = m1;
      if (m2 < min)
        min = m2;
      if (m3 < min)
        min = m3;
      if (m4 < min)
        min = m4;
      
      double max = m1;
      if (m2 > max)
        max = m2;
      if (m3 > max)
        max = m3;
      if (m4 > max)
        max = m4;
      
      _min = min;
      _current *= range._current;
      _consign *= range._consign;
      _max = max;
      
      return *this;
!!!151426.cpp!!!	operator*=(in d : double) : Range
      double min;
      double max;
      if (d < 0)
        {
          min = _max.get_value() * d;
          max = _min.get_value() * d;
        }
      else
        {
          min = _min.get_value() * d;
          max = _max.get_value() * d;
        }
      _min = min;
      _current *= d;
      _consign *= d;
      _max = max;
      
      return *this;
!!!268674.cpp!!!	operator/=(in d : double) : Range
    double min = _min.get_value() / d;
    double max = _max.get_value() / d;
    if (min > max)
      {
        double tmp = min;
        min = max;
        max = tmp;
      }
    _min.set_value(min);
    _current /= d;
    _consign /= d;
    _max.set_value(max);

    return *this;
!!!151554.cpp!!!	contain_zero() : bool
      if (_min <= 0 && _max >= 0)
        return true;
      else
        return false;
!!!269058.cpp!!!	cos() : Range
  double const & min = _min.get_value();
  double const & current = _current.get_value();
  double const & consign = _consign.get_value();
  double const & max = _max.get_value();

  if (max - min >= 2 * hkl::constant::math::pi)
  {
    this->set(-1, ::cos(current), ::cos(consign), 1);
  }
  else
    {
      int quad_min = (int)floor(2 * min / hkl::constant::math::pi) % 4;
      if (quad_min < 0)
        quad_min += 4;

      int quad_max = (int)floor(2 * max / hkl::constant::math::pi) % 4;
      if (quad_max < 0)
        quad_max += 4;

      switch (quad_max)
        {
        case 0:
          switch (quad_min)
            {
            case 0:
              this->set(::cos(max), ::cos(current), ::cos(consign), ::cos(min));
              break;
            case 1:
              this->set(-1, ::cos(current), ::cos(consign), 1);
              break;
            case 2:
              this->set(::cos(min), ::cos(current), ::cos(consign), 1);
              break;
            case 3:
              if (::cos(min) < ::cos(max))
                this->set(::cos(min), ::cos(current), ::cos(consign), 1);
              else
                this->set(::cos(max), ::cos(current), ::cos(consign), 1);
              break;
            }
          break;
        case 1:
          switch (quad_min)
            {
            case 0:
              this->set(::cos(max), ::cos(current), ::cos(consign), ::cos(min));
              break;
            case 1:
              this->set(-1, ::cos(current), ::cos(consign), 1);
              break;
            case 2:
              if (::cos(min) < ::cos(max))
                this->set(::cos(min), ::cos(current), ::cos(consign ), 1);
              else
                this->set(::cos(max), ::cos(current), ::cos(consign), 1);
              break;
            case 3:
              this->set(::cos(max), ::cos(current), ::cos(consign), 1);
              break;
            }
          break;
        case 2:
          switch (quad_min)
            {
            case 0:
              this->set(-1, ::cos(current), ::cos(consign), ::cos(min));
              break;
            case 1:
              if (::cos(min) < ::cos(max))
                this->set(-1, ::cos(current), ::cos(consign), ::cos(max));
              else
                this->set(-1, ::cos(current), ::cos(consign), ::cos(min));
              break;
            case 2:
              if (::cos(min) < ::cos(max))
                this->set(::cos(min), ::cos(current), ::cos(consign), ::cos(max));
              else
                this->set(-1, ::cos(current), ::cos(consign), 1);
              break;
            case 3:
              this->set(-1, ::cos(current), ::cos(consign), 1);
              break;
            }
          break;
        case 3:
          switch (quad_min)
            {
            case 0:
              if (::cos(min) < ::cos(max))
                this->set(-1, ::cos(current), ::cos(consign), ::cos(max));
              else
                this->set(-1, ::cos(current), ::cos(consign), ::cos(min));
              break;
            case 1:
              this->set(-1, ::cos(current), ::cos(consign), ::cos(max));
              break;
            case 2:
              this->set(::cos(min), ::cos(current), ::cos(consign), ::cos(max));
              break;
            case 3:
              if (::cos(min) < ::cos(max))
                this->set(::cos(min), ::cos(current), ::cos(consign), ::cos(max));
              else
                this->set(-1, ::cos(current), ::cos(consign), 1);
              break;
            }
          break;
        }
    }
  return *this;
!!!269186.cpp!!!	acos() : Range
  double min = ::acos(_max.get_value());
  double current = ::acos(_current.get_value());
  double consign = ::acos(_consign.get_value());
  double max = ::acos(_min.get_value());

  this->set(min, current, consign, max);
  return *this;
!!!269314.cpp!!!	sin() : Range
    double min = _min.get_value();
    double current = _current.get_value();
    double consign = _consign.get_value();
    double max = _max.get_value();

    /* if there is at least one period in b, then a = [-1, 1] */
    if ( max - min >= 2 * hkl::constant::math::pi)
        this->set(-1, ::sin(current), ::sin(consign), 1);
    else
      {
        int quad_min = (int)floor(2 * min / hkl::constant::math::pi) % 4;
        if (quad_min < 0)
            quad_min += 4;

        int quad_max = (int)floor(2 * max / hkl::constant::math::pi) % 4;
        if (quad_max < 0)
            quad_max += 4;

        switch (quad_max) {
          case 0:
            switch (quad_min) {
              case 0:
                if (::sin(min) < ::sin(max))
                    this->set(::sin(min), ::sin(current), ::sin(consign), ::sin(max));
                else
                    this->set(-1, ::sin(current), ::sin(consign), 1);
                break;
              case 3:
                this->set(::sin(min), ::sin(current), ::sin(consign), ::sin(max));
                break;
              case 1:
                if (::sin(min) > ::sin(max))
                    this->set(-1, ::sin(current), ::sin(consign), ::sin(min));
                else
                    this->set(-1, ::sin(current), ::sin(consign), ::sin(max));
                break;
              case 2:
                this->set(-1, ::sin(current), ::sin(consign), ::sin(max));
                break;
            }
            break;
          case 1:
            switch (quad_min) {
              case 0:
                if (::sin(min) < ::sin(max))
                    this->set(::sin(min), ::sin(current), ::sin(consign), 1);
                else
                    this->set(::sin(max), ::sin(current), ::sin(consign), 1);
                break;
              case 1:
                if (::sin(min) < ::sin(max))
                    this->set(-1, ::sin(current), ::sin(consign), 1);
                else
                    this->set(::sin(max), ::sin(current), ::sin(consign), ::sin(min));
                break;
              case 2:
                this->set(-1, ::sin(current), ::sin(consign), 1);
                break;
              case 3:
                this->set(::sin(min), ::sin(current), ::sin(consign), 1);
                break;
            }
            break;
          case 2:
            switch (quad_min) {
              case 0:
                this->set(::sin(max), ::sin(current), ::sin(consign), 1);
                break;
              case 1:
              case 2:
                if (::sin(min) < ::sin(max))
                    this->set(-1, ::sin(current), ::sin(consign), 1);
                else
                    this->set(::sin(max), ::sin(current), ::sin(consign), ::sin(min));
                break;
              case 3:
                if (::sin(min) < ::sin(max))
                    this->set(::sin(min), ::sin(current), ::sin(consign), 1);
                else
                    this->set(::sin(max), ::sin(current), ::sin(consign), 1);
                break;
            }
            break;
          case 3:
            switch (quad_min) {
              case 0:
                this->set(-1, ::sin(current), ::sin(consign), 1);
                break;
              case 1:
                this->set(-1, ::sin(current), ::sin(consign), ::sin(min));
                break;
              case 2:
                if(::sin(min) < ::sin(max))
                    this->set(-1, ::sin(current), ::sin(consign), ::sin(max));
                else
                    this->set(-1, ::sin(current), ::sin(consign), ::sin(min));
                break;
              case 3:
                if (::sin(min) < ::sin(max))
                    this->set(::sin(min), ::sin(current), ::sin(consign), ::sin(max));
                else
                    this->set(-1, ::sin(current), ::sin(consign), 1);
                break;
            }
            break;
        }
      }
  return *this;
!!!269442.cpp!!!	asin() : Range
  double min = ::asin(_min.get_value());
  double current = ::asin(_current.get_value());
  double consign = ::asin(_consign.get_value());
  double max = ::asin(_max.get_value());

  this->set(min, current, consign, max);
  return *this;
!!!269570.cpp!!!	tan() : Range
  double const & min = _min.get_value();
  double const & current = _current.get_value();
  double const & consign = _consign.get_value();
  double const & max = _max.get_value();
  
  int quadrant_down = (int)floor( 2 * min / hkl::constant::math::pi);
  int quadrant_up = (int)floor(2 * max / hkl::constant::math::pi);

  /* if there is at least one period in b or if b contains a Pi/2 + k*Pi, */
  /* then a = ]-oo, +oo[ */
std::cout << "min : " << min << "(" << quadrant_down << ") max : " << max << "(" << quadrant_up << ")" << std::endl;
  if ( ((quadrant_up - quadrant_down) >= 2)
       || ((quadrant_down % 2) && !(quadrant_up % 2)) )
      this->set(-hkl::constant::math::infinity, ::tan(current), ::tan(consign), hkl::constant::math::infinity);
  else
      this->set(::tan(min), ::tan(current), ::tan(consign), ::tan(max));
  return *this;
!!!269698.cpp!!!	atan() : Range
  double min = ::atan(_min.get_value());
  double current = ::atan(_current.get_value());
  double consign = ::atan(_consign.get_value());
  double max = ::atan(_max.get_value());
  
  this->set(min, current, consign, max);
  return *this;
!!!151682.cpp!!!	operator==(in range : Range) : bool
    return _current == range._current
           && _consign == range._consign
           && _min == range._min
           && _max == range._max;
!!!151810.cpp!!!	printToStream(inout flux : ostream) : ostream
      flux
      << _current.get_value()
      << " " << _consign.get_value()
      << " [ " << _min.get_value()
      << " : "
      << _max.get_value() << " ]";
      
      return flux;
!!!151938.cpp!!!	toStream(inout flux : ostream) : ostream
      _min.toStream(flux);
      _current.toStream(flux);
      _consign.toStream(flux);
      _max.toStream(flux);
      
      return flux;
!!!152066.cpp!!!	fromStream(inout flux : istream) : istream
      _min.fromStream(flux);
      _current.fromStream(flux);
      _consign.fromStream(flux);
      _max.fromStream(flux);
      
      return flux;
