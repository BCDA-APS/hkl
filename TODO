TODO
  GENERAL
    + Separer les header selon que l'on compile sous win32 ou linux.
    + deplacer les .h dans le repertoire hkl sous include.
    - mettre les __ligne__ et __file__ dans toutes les exceptions.
    ~ realiser le diagramme UML avec dia.
    - Gerer les unités des paramètres
    - ajouter une class abstraite Persistant et deriver Object de cette classe.
    - comment modifier MyVector pour qu'il n'accepte que des classes derivées de object.
    - Ajouter un offset sur les Axes de façon à gérer les changement d'origine.
    - voir comment gérer l'internationalisation de la librairie sous VC++6 et gcc
        utiliser sans doute gettext qui existe aussi pour windows.
    - Utiliser les unsorted_map avec gcc-4.0 à la place de MyVector.
        Créer une class MyUnorderedMap à la place de MyVector.
    - comment gerer le changement de longueur d'onde ?
      - penser aux reflection ainsi qu'aux geometry servant à initialiser les pseudoAxes.
    
  AFFINEMENT
    - utiliser la librairie gsl pour faire les affinements.
    - Rajouter le fit sur les offsets des angles.
    - Ajouter d'autres méthode de résolution plus robustes pour notre problème que le simplex.
    
  GEOMETRY
    + ajout des fonction de conversion E4CV -> K4CV et K6CV
    + ajout des fonctions de conversion K4CV et K6CV -> E4CV
    + ajout des fonctions de conversion K4CV <-> K6C
    - voir a utiliser plutot un myMap<Axe *> plutot que myMap<Axe> de façon à reduire les temps de calcule.
    - class TwoC
    
  AXE

  CRYSTALLIST
    - optimiser le renomage d'un crystal sans faire la copy de celui-ci.
    
  CRYSTALS
    + Avoir la possibilité de rajouter une description du crystal.
        (m_description de Object)
    + s'assurer que l'on utilise que les bonnes reflections lors de l'affinement.
    - Ajouter le calcule de l'angle mesuré ainsi que de l'angle calculé entre
        deux reflections.
    - voir comment indiquer que les valeurs des angles alpha beta gamma ne sont
        pas compatibles dans le constructeur.
  
  DIFFRACTOMETRE
    + Kappa4C
    + Kappa6C
    + TwoC
    
  MODES
    - Revoir la conversion de E4C -> Horizontal4C. ne pas oublier le décalage de
        chi de 90°.
    - Penser au problème des freeze des moteurs lorsque l'on change de mode de
        façon a savoir si l'angle configuration passé en paramètre lors du
        calcul permet de faire un calcule juste.
    - Gerer correctement les limites dans les modes suivant la valeurs des
        paramêtres des modes.
    - revoir l'ecriture du code de kapp6C et kappa4C
    + TwoC
      + "symetric" (omega = theta, 2theta = 2 * theta
      + "fix incidence" (omega = free, 2theta = 2 * theta)
    - E4C
      - Mode "zone"
    - E6C
      - Mode "Horizontal Eulerian 4C zone"
      - Mode "Vertical Eulerian 4C zone"
    - K4CV
      + "Eulerian 4C Bissector"
      + "Eulerian 4C Delta Theta"
      + "Eulerian 4C Constant Omega"
      + "Eulerian 4C Constant Chi"
      + "Eulerian 4C Constant Phi"
    - K6C::E4CV
      + "Eulerian 4C Bissector"
      + "Eulerian 4C Delta Theta"
      + "Eulerian 4C Constant Omega"
      + "Eulerian 4C Constant Chi"
      + "Eulerian 4C Constant Phi"
      - "Bras levant"
      
    - K4C utiliser la decomposition de Bricogne pour gerer les modes.
    - Retourner l'ensemble des solutions et non pas une seule.
    - Sélection de la solution intéressante parmis les précédentes suivant diverses statégies.

  REFLECTIONS
    - voir que faire de la relevance.
    
  PSEUDOMOTORS
    - rajouter les toStream et fromStream pour les versions MSVC6
    - ajouter un champ m_value a pseudoAxe et le mettre à jour lors du set_value().
      De cette façon lors d'un get_value() on peut savoir s'il faut + ou - pi par exemple.
    - TwoC
      + "th2th": omega - 2theta (domega = d2theta / 2)
      + "q2th" : omega - 2theta (domega = d2theta / 2) but q2th = 2 tau sin(theta) / lambda
      + "q" : 2 * tau * sin(theta) / lambda
    - E4C
      + "psi"
      + "th2th": omega - 2theta (domega = d2theta / 2)
      + "q2th" : omega - 2theta (domega = d2theta / 2) but q2th = 2 tau sin(theta) / lambda
      + "q" : 2 * tau * sin(theta) / lambda
    - E6C
      + "Tth" : 2 * theta
      + "q" : 2 * tau * sin(theta) / lambda
      + "psi_v"
    - K4C
      + "omega"
      + "chi"
      + "phi"
      + "psi"
      + "th2th": omega - 2theta (domega = d2theta / 2)
      + "q2th" : omega - 2theta (domega = d2theta / 2) but q2th = 2 tau sin(theta) / lambda
      + "q" : 2 * tau * sin(theta) / lambda
    - K6C
      + "omega_v"
      + "chi_v"
      + "phi_v"
      + "psi_v"
      + "tth" : 2 * theta
      + "q" : 2 * tau * sin(theta) / lambda

  SERIALIZATION
    + Sérialiser l'ensemble de la librairie.
    - comment gérer le cas du Nan et +/-Inf.

  TEST
    + pseudoAxe::kappa6C
    + geometry::twoC::Vertical
    + pseudoAxe::twoC::Vertical
    + mode::twoC::Vertical
    + mode::*
    + diffractometer::twoC::Vertical
    - revoir setFromGeometry
    - revoir Axe, Reflection, Mode, Object, Diffractometer, FitParameter
    - faire les tests de convenience
    - faire les tests de diffractometer::kappa4C
    - faire les tests de diffractometer::kappa6C
    - faire un test plus exhaustif des fonctions de conversion E4C <-> K4C.

  DOCUMENTATION
    ~ API
    - Toujours plus de documentation.
    - Expliquer comment rajouter des diffractomètres et des modes à la librairie.
  
  BINDING
    ~ python
    - Autres languages.

  FRONTEND
    ~ Developper une interface graphique à la librairie pour la tester.
