TODO
  GENERAL
    + deplacer les .h dans le repertoire hkl sous include.
    + mettre les __ligne__ et __file__ dans toutes les exceptions.
    ~ realiser le diagramme UML avec dia.
    - mettre tau comme étant un paramètre des diffractomètres. 2 valeurs possibles.
    - Gerer les unités des paramètres
    - ajouter les méthodes permettant l'aide à la décision pour l'indexation.
    - modifier le comportement de computeHKL lorsque le crystal en question est soit une poudre soit un mono-cristal.

    - ajouter une class abstraite Persistant et deriver Object de cette classe.
    - comment modifier MyVector pour qu'il n'accepte que des classes derivées de object.
    - voir comment gérer l'internationalisation de la librairie sous VC++6 et gcc
        utiliser sans doute gettext qui existe aussi pour windows.
    - Utiliser les unordered_map avec gcc-4.0 à la place de MyVector.
        Créer une class MyUnorderedMap à la place de MyVector.
    - comment gerer le changement de longueur d'onde ?
      - penser aux reflection ainsi qu'aux geometry servant à initialiser les pseudoAxes.
    
  AFFINEMENT
    - utiliser la librairie gsl pour faire les affinements.
    - Rajouter le fit sur les offsets des angles.
    - Ajouter d'autres méthode de résolution plus robustes pour notre problème que le simplex.
    
  GEOMETRY
    - dans les fonctions de conversion il faut pouvoir faire intervenir la précision des angles.
    - utiliser le patern desing Observable pour mettre à jour les pseudoAxes.
    + ajout des fonction de conversion E4CV -> K4CV et K6CV
    + ajout des fonctions de conversion K4CV et K6CV -> E4CV
    + ajout des fonctions de conversion K4CV <-> K6C
    + voir a utiliser plutot un myMap<Axe *> plutot que myMap<Axe> de façon à reduire les temps de calcule.
    + class TwoC
    
  AXE
    - ecrire un AxeInterface
    - remplacer get_min et get_max par get_range.
    - Ajouter un offset sur les Axes de façon à gérer les changement d'origine.

  CRYSTALLIST
    - optimiser le renomage d'un crystal sans faire la copy de celui-ci.
    
  CRYSTALS
    + Avoir la possibilité de rajouter une description du crystal.
        (m_description de Object)
    + s'assurer que l'on utilise que les bonnes reflections lors de l'affinement.
    - ajouter un champ qui indique si le cristal est un monocristal ou une poudre.
    - ajouter le calcule du volume de la maille.
    - Ajouter le calcule de l'angle mesuré ainsi que de l'angle calculé entre
        deux reflections.
    - voir comment indiquer que les valeurs des angles alpha beta gamma ne sont
        pas compatibles dans le constructeur.
    - Penser à ajouter un paramètre U matrice d'orientation plutot que euler_x, y et z.
  
  DIFFRACTOMETRE
    + Kappa4C
    + Kappa6C
    + TwoC
    
  MODES
    - Gerer correctement les limites dans les modes suivant la valeurs des
        paramêtres des modes.
    + revoir l'ecriture du code de kappa6C et kappa4C
    + TwoC
      + "symetric" (omega = theta, 2theta = 2 * theta
      + "fix incidence" (omega = free, 2theta = 2 * theta)
    - E4C
      - Mode "zone"
    - E6C
      - Mode "Horizontal Eulerian 4C zone"
      - Mode "Vertical Eulerian 4C zone"
    - K4CV
      + "Eulerian 4C Bissector"
      + "Eulerian 4C Delta Theta"
      + "Eulerian 4C Constant Omega"
      + "Eulerian 4C Constant Chi"
      + "Eulerian 4C Constant Phi"
    - K6C::E4CV
      + "Eulerian 4C Bissector"
      + "Eulerian 4C Delta Theta"
      + "Eulerian 4C Constant Omega"
      + "Eulerian 4C Constant Chi"
      + "Eulerian 4C Constant Phi"
      - "Bras levant"
      
    - K4C utiliser la decomposition de Bricogne pour gerer les modes.
    - Retourner l'ensemble des solutions et non pas une seule.
    - Sélection de la solution intéressante parmis les précédentes suivant diverses statégies.

  REFLECTIONS
    - ajouter un flag or0 et or1 pour le calcule de UB avec la methode busing et Levy.
    - voir que faire de la relevance.

    
  PSEUDOMOTORS
    - rajouter les toStream et fromStream pour les versions MSVC6
    - ajouter un champ m_value a pseudoAxe et le mettre à jour lors du set_value().
      De cette façon lors d'un get_value() on peut savoir s'il faut + ou - pi par exemple.
    - Au lieu de get_min et get_max mettre un get_range et créer une classe Range sur laquelle
      on peut fair des calculs du genre cos(range) qui retourne un range.
      Il faudrait donc séparer le Range de la Value pour que le range soit composé de deux Values
      min et max. De plus il suffirait alors de s'occuper de cette classe Value pour gérer les unitées.
      Ces calcules sur les ranges existe dans boost.
    - Vérifier lors d'un set_value que l'on est bien dans le range du pseudoAxe.
    - Relier le pseudoAxe aux moteurs de la géométrie qu'il modifie.
    - TwoC
      + "th2th": omega - 2theta (domega = d2theta / 2)
      + "q2th" : omega - 2theta (domega = d2theta / 2) but q2th = 2 tau sin(theta) / lambda
      + "q" : 2 * tau * sin(theta) / lambda
    - E4C
      + "psi"
      + "th2th": omega - 2theta (domega = d2theta / 2)
      + "q2th" : omega - 2theta (domega = d2theta / 2) but q2th = 2 tau sin(theta) / lambda
      + "q" : 2 * tau * sin(theta) / lambda
    - E6C
      + "Tth" : 2 * theta
      + "q" : 2 * tau * sin(theta) / lambda
      + "psi_v"
    - K4C
      + "omega"
      + "chi"
      + "phi"
      + "psi"
      + "th2th": omega - 2theta (domega = d2theta / 2)
      + "q2th" : omega - 2theta (domega = d2theta / 2) but q2th = 2 tau sin(theta) / lambda
      + "q" : 2 * tau * sin(theta) / lambda
    - K6C
      + "omega_v"
      + "chi_v"
      + "phi_v"
      + "psi_v"
      + "tth" : 2 * theta
      + "q" : 2 * tau * sin(theta) / lambda

  SERIALIZATION
    + Sérialiser l'ensemble de la librairie.
      Lors du passage à un compilateur > MSVC6 penser à utiliser boost pour cela.
    - comment gérer le cas du Nan et +/-Inf.

  TEST
    + pseudoAxe::kappa6C
    + geometry::twoC::Vertical
    + pseudoAxe::twoC::Vertical
    + mode::twoC::Vertical
    + mode::*
    + diffractometer::twoC::Vertical
    - revoir LatticeTest::randomize()
    - revoir setFromGeometry
    - revoir Axe, Reflection, Mode, Object, Diffractometer, FitParameter
    - faire les tests de convenience
    - faire les tests de diffractometer::kappa4C
    - faire les tests de diffractometer::kappa6C
    - faire un test plus exhaustif des fonctions de conversion E4C <-> K4C.

  DOCUMENTATION
    ~ API
    - Toujours plus de documentation.
    - Expliquer comment rajouter des diffractomètres et des modes à la librairie.
  
  BINDING
    ~ python
    - Autres languages.

  FRONTEND
    ~ Developper une interface graphique à la librairie pour la tester.
