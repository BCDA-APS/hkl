\input texinfo   @c -*-texinfo-*-
@comment %**start of header
@setfilename hkl.info
@include version.texi
@settitle Hkl Diffraction Library @value{VERSION}
@syncodeindex pg cp
@comment %**end of header
@copying
This manual is for hkl Library (version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2003-2010 Synchrotron SOLEIL
                       L'Orme des Merisiers Saint-Aubin
                       BP 48 91192 GIF-sur-YVETTE CEDEX

@quotation
The hkl library is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The hkl library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with the hkl library.  If not, see <http://www.gnu.org/licenses/>.
@end quotation
@end copying

@dircategory Software libraries
@direntry
* hkl: (hkl).           Library for hkl diffraction computation.
@end direntry

@titlepage
@title hkl Library
@subtitle for version @value{VERSION}, @value{UPDATED}
@author F-E. Picca (@email{picca@@synchrotorn-soleil.fr})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top hkl Diffraction Library

This manual is for Hkl Diffraction Library (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

@menu
* Introduction::                
* Diffractometer::              
* Developpement::               
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Diffractometer

* Eulerian 4 circles vertical::  
* Eulerian 6 circles::          
* Kappa 4 circles vertical::    
* Kappa 6 circles::             
* Z-axis::                      
* SOLEIL SIXS MED2+2::          

@end detailmenu
@end menu

@node Introduction, Diffractometer, Top, Top
@chapter Introduction

The purpose of the library is to factories diffraction angles computation for
different kind of diffractometers geometries. It is used at the SOLEIL, Desy
and Alba synchrotron with the Tango control system to pilot diffractometers.

@section Features

@itemize
@item mode computation (aka PseudoAxis)
        @itemize
        @item for different diffractometer geometries.
        @end itemize
@item UB matrix computation.
      @itemize
        @item busing & Levy with 2 reflections
        @item simplex computation with more than 2 reflections using the GSL library.
        @item Eulerians angles to pre-orientate your sample.
      @end itemize
@item Crystal lattice affinement
      @itemize
        @item with more than 2 reflections you can select which parameter must be fitted.
      @end itemize
@item Pseudoaxes
      @itemize
        @item psi, eulerians, q, ...
      @end itemize
@end itemize

@section Conventions.

In all this document the next convention will be used to describe the diffractometers
geometries.
@itemize
@item right handed convention for all the angles.
@item direct space orthogonal base.
@item description of the diffractometer geometries is done with all axes values set to zero.
@end itemize

@node Diffractometer, Developpement, Introduction, Top
@chapter Diffractometer

@menu
* Eulerian 4 circles vertical::  
* Eulerian 6 circles::          
* Kappa 4 circles vertical::    
* Kappa 6 circles::             
* Z-axis::                      
* SOLEIL SIXS MED2+2::          
@end menu

@node Eulerian 4 circles vertical, Eulerian 6 circles, Diffractometer, Diffractometer
@section Eulerian 4 circles vertical

@subsection Geometry

@itemize
    @item xrays source fix allong the @math{\vec{x}} direction (1, 0, 0)
    @item 3 axes for the sample
          @itemize
                @item @samp{omega} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
                @item @samp{chi} : rotating around the @math{\vec{x}} direction (1, 0, 0)
                @item @samp{phi} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
    @item 1 axis for the detector
          @itemize
                @item @samp{tth} : rotation around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
@end itemize

@subsection Pseudo axis @samp{hkl}

PseudoAxes provided : @samp{h}, @samp{k} and @samp{l}

@subsubsection mode @samp{bissector}

@itemize
@item Axes : @samp{omega}, @samp{chi}, @samp{phi}, @samp{tth}
@item Parameters : No parameter
@end itemize

This mode add the bissector constrain @code{tth = 2 * omega}. In this mode the @samp{chi}
circle containt the vector of diffusion @math{\vec{Q}}. So it is easy to know the orientation
of the hkl plan.

@subsubsection mode @samp{constant_omega}

@itemize
@item Axes : @samp{chi}, @samp{phi}, @samp{tth}
@item Parameters : No parameter
@end itemize

This mode do not move the current @samp{omega} axis.

@subsubsection mode @samp{constant_chi}

@itemize
@item Axes :  @samp{omega}, @samp{phi}, @samp{tth}
@item Parameters : No parameter
@end itemize

This mode do not move the current @samp{chi} axis.

@subsubsection mode @samp{constant_phi}

@itemize
@item Axes related : @samp{omega}, @samp{chi}, @samp{tth}
@item Parameters : No parameter
@end itemize
This mode do not move the current @samp{phi} axis.

@subsubsection mode @samp{double_diffraction}

@itemize
@item Axes : @samp{omega}, @samp{chi}, @samp{phi}, @samp{tth}
@item Parameters : @samp{h2}, @samp{k2}, @samp{l2}
@end itemize

This mode put a second hkl vector (@samp{h2}, @samp{k2}, @samp{l2}) in Bragg condition.
This is usefull sometimes when you want to explore two bragg peaks without moving your sample.

@subsubsection mode @samp{psi_constant}

@itemize
@item Axes :  @samp{omega}, @samp{chi}, @samp{phi}, @samp{tth}
@item Parameters : @samp{h2}, @samp{k2}, @samp{l2}, @samp{psi}
@end itemize

This mode allow to fix the value of the pseudo axis @samp{psi} at a constant value when you move
around an @samp{h}, @samp{k} ,@samp{l} position. The (@samp{h2}, @samp{k2}, @samp{l2}) vector is
used as a reference for the computation of the @samp{psi} pseudo axis value.

You can retrive and ``freeze'' the current value of the @samp{psi} pseudo axis value into the
@samp{psi} parameter when you initialize the mode. But you can also write directly the value
of the desired @samp{psi} parameter.

@subsection PseudoAxis @samp{psi}

PseudoAxis provided : @samp{psi}

@subsubsection mode @samp{psi}

@itemize
@item Axes : @samp{omega}, @samp{chi}, @samp{phi}, @samp{tth}
@item Parameters : @samp{h1}, @samp{k1},@samp{l1}
@end itemize

@node Eulerian 6 circles, Kappa 4 circles vertical, Eulerian 4 circles vertical, Diffractometer
@section Eulerian 6 circles

@subsection Geometry

@itemize
    @item xrays source fix allong the @math{\vec{x}} direction (1, 0, 0)
    @item 4 axes for the sample
          @itemize
                @item @samp{mu} : rotating around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{omega} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
                @item @samp{chi} : rotating around the @math{\vec{x}} direction (1, 0, 0)
                @item @samp{phi} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
    @item 2 axes for the detector
          @itemize
                @item @samp{gamma} : rotation around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{delta} : rotation around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
@end itemize

@subsection PseudoAxes

@node Kappa 4 circles vertical, Kappa 6 circles, Eulerian 6 circles, Diffractometer
@section Kappa 4 circles vertical

@subsection Geometry

For this geometry there is a special parameters called @math{\alpha} which is the
angle between the kappa rotation axis and the  @math{\vec{y}} direction.

@itemize
    @item xrays source fix allong the @math{\vec{x}} direction (1, 0, 0)
    @item 3 axes for the sample
          @itemize
                @item @samp{komega} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
                @item @samp{kappa} : rotating around the @math{\vec{x}} direction (0, @math{-\cos\alpha}, @math{-\sin\alpha})
                @item @samp{kphi} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
    @item 1 axis for the detector
          @itemize
                @item @samp{tth} : rotation around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
@end itemize

@subsection PseudoAxes

@node Kappa 6 circles, Z-axis, Kappa 4 circles vertical, Diffractometer
@section Kappa 6 circles

@subsection Geometry

For this geometry there is a special parameters called @math{\alpha} which is the
angle between the kappa rotation axis and the  @math{\vec{y}} direction.

@itemize
    @item xrays source fix allong the @math{\vec{x}} direction (1, 0, 0)
    @item 4 axes for the sample
          @itemize
                @item @samp{mu} : rotating around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{komega} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
                @item @samp{kappa} : rotating around the @math{\vec{x}} direction (0, @math{-\cos\alpha}, @math{-\sin\alpha})
                @item @samp{kphi} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
    @item 2 axes for the detector
          @itemize
                @item @samp{gamma} : rotation around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{delta} : rotation around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
@end itemize

@subsection PseudoAxes

@node Z-axis, SOLEIL SIXS MED2+2, Kappa 6 circles, Diffractometer
@section Z-Axis

@subsection Geometry

For this geometry the @samp{mu} axis is common to the sample and the detector.

@itemize
    @item xrays source fix allong the @math{\vec{x}} direction (1, 0, 0)
    @item 2 axes for the sample
          @itemize
                @item @samp{mu} : rotation around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{omega} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
    @item 3 axis for the detector
          @itemize
                @item @samp{mu} : rotation around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{delta} : rotation around the @math{-\vec{y}} direction (0, -1, 0)
                @item @samp{gamma} : rotation around the @math{\vec{z}} direction (0, 0, 1)
          @end itemize
@end itemize

@subsection PseudoAxes

PseudoAxes provided : @samp{h}, @samp{k} and @samp{l}

@subsubsection mode @samp{zaxis}

@itemize
@item Axes : @samp{omega}, @samp{delta}, @samp{gamma}
@item Parameters : No parameter
@end itemize

@subsubsection mode @samp{reflectivity}

@itemize
@item Axes : @samp{mu}, @samp{omega}, @samp{delta}, @samp{gamma}
@item Parameters : No parameter
@end itemize

This mode add the reflectivity constraint @code{mu = gamma}. The
incomming beam angle and the outgoing beam angle are equals.

@node SOLEIL SIXS MED2+2,  , Z-axis, Diffractometer
@section SOLEIL SIXS MED2+2

@subsection Geometry

@itemize
    @item xrays source fix allong the @math{\vec{x}} direction (1, 0, 0)
    @item 2 axes for the sample
          @itemize
                @item @samp{mu} : rotation around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{omega} : rotating around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
    @item 3 axis for the detector
          @itemize
                 @item @samp{gamma} : rotation around the @math{\vec{z}} direction (0, 0, 1)
                @item @samp{delta} : rotation around the @math{-\vec{y}} direction (0, -1, 0)
          @end itemize
@end itemize

@subsection Pseudo axis @samp{hkl}

PseudoAxes provided : @samp{h}, @samp{k} and @samp{l}

@subsubsection mode @samp{mu_fixed}

@itemize
@item Axes : @samp{omega}, @samp{gamma}, @samp{delta}
@item Parameters : No parameter
@end itemize

@node Developpement, Index, Diffractometer, Top
@chapter Developpement

@section Getting hkl

To get hkl, you can download the last stable version from sourceforge or if you
want the latest development version use @uref{http://git.or.cz/, git} or
@uref{http://code.google.com/p/msysgit/downloads/list, msysgit} on windows system and
do
@example
$ git clone git://repo.or.cz/hkl.git
@end example
or
@example
$ git clone http://repo.or.cz/r/hkl.git (slower)
@end example
then checkout the next branch like this.
@example
$ cd hkl
$ git checkout -b next origin/next
@end example

@section Building hkl

To build hkl you need @uref{http://www.python.org, Python 2.3+} and the
@uref{http://www.gnu.org/software/gsl/, GNU Scientific Library 1.12+}
@example
$ ./waf configure
$ ./waf
$ ./waf install (as root)
@end example

This command compile the library and the test suit if everythings goes fine you
must have a @file{libhkl.so.@value{VERSION}} or @file{libhkl.lib} depending on your
platform in the @file{build/default/src} directory. If your platform is not supported yet please
contact the @email{picca@@synchrotron-soleil.fr}.

@section Hacking hkl

you can send your patch to the @email{picca@@synchrotron-soleil.fr} using
git

The developpement process is like this. suppose you wan to add a new feature to
hkl create first a new branch from the next one
@example
$ git checkout -b my-next next
@end example
then work...
@example
$ git commit -a
@end example
more work...
@example
$ git commit -a
@end example
now that your great feature is ready for publication, you can send by mail your
patches process like this:
@example
$ git format-patch origin/next
@end example
and send files @file{0001_xxx}  and @file{0002_xxx} created to the author.

@subsection Howto add a diffractometer

In this section we will describe all steps needed to add a diffractometer. We
will use the kappa 4 circles exemple.

@subsection Adding Geometry

The first thing to do is to add the Geometry of this diffractometer.  you need
to edit the @file{hkl/hkl-geometry-factory.h} file

add a new @code{HKL_GEOMETRY_KAPPA4C_VERTICAL} const to the @code{_HklGeometryType}

@verbatim
enum _HklGeometryType
{
	...
	HKL_GEOMETRY_KAPPA4C_VERTICAL
}
@end verbatim

Now you must describe the diffractometer axes and the way they are connected
all togethers.  This diffractometer have one sample holder and one detecter
holder and four axes ("komega", "kappa", "kphi" and "tth") So you need to add a
new init method for this diffractometer.

@verbatim
static void hkl_geometry_init_kappa4C_vertical(HklGeometry *self, double alpha)
{
	HklHolder *h;

	self->name = "K4CV";
	h = hkl_geometry_add_holder(self);
	hkl_holder_add_rotation_axis(h, "komega", 0, -1, 0);
	hkl_holder_add_rotation_axis(h, "kappa", 0, -cos(alpha), -sin(alpha));
	hkl_holder_add_rotation_axis(h, "kphi", 0, -1, 0);

	h = hkl_geometry_add_holder(self);
	hkl_holder_add_rotation_axis(h, "tth", 0, -1, 0);
}
@end verbatim

first we set the diffractometer name by


@verbatim
self->name = "K4CV";
@end verbatim

This name is used in the Tango diffractometer device to refer this diffractometer.

Then you can create the first holder with it's three axes. The order of the axis is from
the farest to the closest of the sample. In this case, komega -> kappa -> kphi.

@verbatim
h = hkl_geometry_add_holder(self);
hkl_holder_add_rotation_axis(h, "komega", 0, -1, 0);
hkl_holder_add_rotation_axis(h, "kappa", 0, -cos(alpha), -sin(alpha));
hkl_holder_add_rotation_axis(h, "kphi", 0, -1, 0);
@end verbatim

Same thing for the other holder holding the detector.

@verbatim
h = hkl_geometry_add_holder(self);
hkl_holder_add_rotation_axis(h, "tth", 0, -1, 0);
@end verbatim

now it is almost finish for the geometry part. you just need to add it in the factory

@verbatim
Hklgeometry *hkl_geometry_factory_new(HklGeometryType type, ...)
{
	...
	switch(type){
		...
		case HKL_GEOMETRY_KAPPA4C_VERTICAL:
			va_start(ap, type);
			alpha = va_arg(ap, double);
			va_end(ap);
			hkl_geometry_init_kappa4C_vertical(geom, alpha);
		break;
	}
	...
}
@end verbatim

in this exemple the geometry take one parameter. The fatory can have a variable
number of parameters you just need to take care of this with the va_arg
methods.

@subsection Adding PseudoAxis mode

Suppose you want to add a new mode to the hkl pseudo axes.
lets call it "psi constant vertical" to the eulerian 6 circle geometry.

The starting point is to look in the @file{src/hkl-pseudoaxis-factory.c} for

@verbatim
HklPseudoAxisEngineList *hkl_pseudo_axis_engine_list_factory(HklGeometryType type)
@end verbatim

in that method you can see this in the eulerian 6 circle part

@verbatim
case HKL_GEOMETRY_EULERIAN6C:
     hkl_pseudo_axis_engine_list_add(self, hkl_pseudo_axis_engine_e6c_hkl_new());
     hkl_pseudo_axis_engine_list_add(self, hkl_pseudo_axis_engine_e6c_psi_new());
     hkl_pseudo_axis_engine_list_add(self, hkl_pseudo_axis_engine_q2_new());
     break;
@end verbatim

so as you can see there is three pseudo axis engine for this geometry. Your mode if for
the hkl pseudo axis. so let look in the @code{hkl_pseudo_axis_engine_e6c_hkl_new()} method.
You can find it in the @file{include/hkl/hkl-pseudoaxis-e6c.h} which contain this:

@verbatim
#ifndef __HKL_PSEUDOAXIS_E6C_H__
#define __HKL_PSEUDOAXIS_E6C_H__

#include <hkl/hkl-pseudoaxis-auto.h>

HKL_BEGIN_DECLS

extern HklPseudoAxisEngine *hkl_pseudo_axis_engine_e6c_hkl_new(void);
extern HklPseudoAxisEngine *hkl_pseudo_axis_engine_e6c_psi_new(void);

HKL_END_DECLS

#endif /* __HKL_PSEUDOAXIS_E6C_H__ */
@end verbatim

strange only 2 methods nothing about @code{hkl_pseudo_axis_engine_q2_new()}. This is because
the implementation of this method is common to more than one geometry. So you can find it in
@file{hkl/hkl-pseudoaxis-common-q.h}

now you need to change the code of @code{hkl_pseudo_axis_engine_e6c_hkl_new(void)}. Lets
look about it in @file{src/hkl-pseudoaxis-e6c-hkl.c}

@verbatim
HklPseudoAxisEngine *hkl_pseudo_axis_engine_e6c_hkl_new(void)
{
	HklPseudoAxisEngine *self;
	HklPseudoAxisEngineMode *mode;

	self = hkl_pseudo_axis_engine_hkl_new();

	/* bissector_vertical */
	mode = hkl_pseudo_axis_engine_mode_new(
		"bissector_vertical",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_setter_func_bissector_vertical,
		0,
		4, "omega", "chi", "phi", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* constant_omega_vertical */
	mode = hkl_pseudo_axis_engine_mode_new(
		"constant_omega_vertical",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_hkl_real,
		0,
		3, "chi", "phi", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* constant_chi_vertical */
	mode = hkl_pseudo_axis_engine_mode_new(
		"constant_chi_vertical",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_hkl_real,
		0,
		3, "omega", "phi", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* constant_phi_vertical */
	mode = hkl_pseudo_axis_engine_mode_new(
		"constant_phi_vertical",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_hkl_real,
		0,
		3, "omega", "chi", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* lifting_detector_phi */
	mode = hkl_pseudo_axis_engine_mode_new(
		"lifting_detector_phi",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_hkl_real,
		0,
		3, "phi", "gamma", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* lifting_detector_omega */
	mode = hkl_pseudo_axis_engine_mode_new(
		"lifting_detector_omega",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_hkl_real,
		0,
		3, "omega", "gamma", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* lifting_detector_mu */
	mode = hkl_pseudo_axis_engine_mode_new(
		"lifting_detector_mu",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_hkl_real,
		0,
		3, "mu", "gamma", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* double_diffraction vertical*/
	HklParameter h2;
	HklParameter k2;
	HklParameter l2;

	hkl_parameter_init(&h2, "h2", -1, 1, 1,
			   HKL_TRUE, HKL_TRUE,
			   NULL, NULL);
	hkl_parameter_init(&k2, "k2", -1, 1, 1,
			   HKL_TRUE, HKL_TRUE,
			   NULL, NULL);
	hkl_parameter_init(&l2, "l2", -1, 1, 1,
			   HKL_TRUE, HKL_TRUE,
			   NULL, NULL);

	mode = hkl_pseudo_axis_engine_mode_new(
		"double_diffraction_vertical",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_double_diffraction_real,
		3, &h2, &k2, &l2,
		4, "omega", "chi", "phi", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* bissector_horizontal */
	mode = hkl_pseudo_axis_engine_mode_new(
		"bissector_horizontal",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_setter_func_bissector_horizontal,
		0,
		5, "mu", "omega", "chi", "phi", "gamma");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	/* double_diffraction_horizontal */
	mode = hkl_pseudo_axis_engine_mode_new(
		"double_diffraction_horizontal",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_double_diffraction_real,
		3, &h2, &k2, &l2,
		4, "mu", "chi", "phi", "gamma");
	hkl_pseudo_axis_engine_add_mode(self, mode);

	hkl_pseudo_axis_engine_select_mode(self, 0);

	return self;
}
@end verbatim

so you "just" need to add a new mode like this

@verbatim
	/* double_diffraction_horizontal */
	mode = hkl_pseudo_axis_engine_mode_new(
		"psi_constant_vertical",
		NULL,
		hkl_pseudo_axis_engine_mode_get_hkl_real,
		hkl_pseudo_axis_engine_mode_set_psi_constant_vertical,
		3, &h2, &k2, &l2,
		4, "omega", "chi", "phi", "delta");
	hkl_pseudo_axis_engine_add_mode(self, mode);
@end verbatim

So the first parameter of the hkl_pseudo_axis_engine_mode_new method
@itemize
@item name is the name of the mode
@item then the init functions (usually you need to store the current state of the geometry
 to be able to use the pseudo axis). Here no need for this init method
so we put @code{NULL}.
@item then the get method which compute for a given geometry the pseudo axis value.
the hkl get method @code{hkl_pseudo_axis_engine_mode_get_hkl_real} is completely generic
and do not depend of the geometry. No need to write it.
@item then the set method which compute a geometry for the given pseudo axis values.
Now you need to work a little bit and write the set method.
@item the parameters of your mode 
@item * first the number of parameters : 3
@item * then each parameters (pointer on the right parameters)
for this mode we have 3 parameters h2, k2, l2 which are the coordinates of a
sample reference direction use to compute the psi value.
@item the name of axes used by the set method.
@item * first the number of axes used by the set method : 4
@item * then all axes names.
@end itemize

In fact the "set" method know nothing about the axes names.
so you can use a set method with different kind of geometries.
the association is only done during the mode creation.

At the end you need to add this mode to the pseudo axis engine with
@code{hkl_pseudo_axis_engine_add_mode(self, mode)};

that's all.

Now let see how this "set" method could be written. In our case we want
to compute the geometry angles for a given h, k, l pseudo axis values keeping the
angle between the reference reciprocal space vector (h2, k2, l2) and the
diffraction plane defined by the incomming beam and the outgoing beam.

@verbatim
static int hkl_pseudo_axis_engine_mode_set_psi_constant_vertical(HklPseudoAxisEngine *engine,
								 HklGeometry *geometry,
								 HklDetector *detector,
								 HklSample *sample)
{
	hkl_pseudo_axis_engine_prepare_internal(engine, geometry, detector,
						sample);

	return hkl_pseudo_axis_engine_solve_function(engine, psi_constant_vertical);
}
@end verbatim

the prepare internal part is about initializing the solver with the given
geometry, detector and sample. Then comes the hkl_pseudo_axis_engine_solve_function
which need the psi_constant_vertical function to work. This method use the GSL library
to find the given function roots (where f(x) = 0).
Lets see how it works for the "bissector_horizontal" mode.

@verbatim
static int bissector_horizontal(const gsl_vector *x, void *params, gsl_vector *f)
{
	double mu, omega, gamma;
	double const *x_data = gsl_vector_const_ptr(x, 0);
	double *f_data = gsl_vector_ptr(f, 0);

	RUBh_minus_Q(x_data, params, f_data);

	mu = x_data[0];
	omega = x_data[1];
	gamma = x_data[4];

	f_data[3] = omega;
	f_data[4] = gamma - 2 * fmod(mu, M_PI);

	return  GSL_SUCCESS;
}
@end verbatim

The bissector_horizotal method is used by the setter method of the mode to
compute the right set of axes angles corresponding to the pseudo axes values
you want to reach. This method compute the difference between these pseudo axes
values and the ones computed from the axes angles. It can be decompose in three
parts:

The first three of these equations are given for the function @code{RUBH_minus_Q}:
they are the  diference between the h,k,l values that want to be set and the h,k,l
values computed for a possible combination of angles:

@example
f_data[0] = h-h(x)
f_data[1] = k-k(x)
f_data[2] = l-l(x)
@end example

As the bissector_horizontal mode use 5 axes you need to find 2 other
equations to be able to solve your mode. The first one
is @math{omega = 0} for an horizontal mode:

@example
f_data[3] = omega
@end example

and the last one is for the bissector parameter @math{gamma = 2 * mu}.

@example
f_data[4] = gamma - 2 * fmod(mu, M_PI)
@end example

One question could be why this complicate @code{f4 = gamma - 2 * fmod(mu, M_PI)}
equation instead of a simpler @code{f4 = gamma - 2 * mu} ?
this is because the bissector_horizontal method is also called by a solution
multiplicator to gives the user plenty of equivalent solutions. This multiplicator
do some operations like @code{omega = pi - omega} or @code{omega = - omega} on the axes.
Then it check that the new angles combination gives also @math{f(x) = 0}. This is the
explaination of this more complicate equation.

So in our case we need to build something like

@verbatim
static int psi_constant_vertical(const gsl_vector *x, void *params, gsl_vector *f)
{
	double mu, omega, gamma;
	double const *x_data = gsl_vector_const_ptr(x, 0);
	double *f_data = gsl_vector_ptr(f, 0);

	RUBh_minus_Q(x_data, params, f_data);

	f_data[3] = ???;

	return  GSL_SUCCESS;
}
@end verbatim

The missing part is about the psi computation. f3 = psi (target) - psi(x).
Calculation psi is done in the psi pseudo axis common part.

@example
static int psi(const gsl_vector *x, void *params, gsl_vector *f)
@end example

This psi method is the equivalent of psi_constant_vertical. So you need
to factorize the psi calculation in between psi_constant_vertical and
psi.

@node Index,  , Developpement, Top
@unnumbered Index

@printindex cp

@bye
