#+TITLE: Welcome to hkl's @VERSION@ documentation!
#+AUTHOR: Picca Frédéric-Emmanuel
#+EMAIL: picca at synchrotron dash soleil dot fr
#+LANGUAGE: en
#+HTML_MATHJAX: path:"/usr/share/javascript/mathjax/MathJax.js"
#+STYLE: <style>table.center {margin-left:auto; margin- right:auto;}</style>

* Introduction
  The purpose of the library is to factorise single crystal
  diffraction angles computation for different kind of diffractometer
  geometries. It is used at the SOLEIL, Desy and Alba synchrotron with
  the Tango control system to pilot diffractometers.
** Features
   - mode computation (aka PseudoAxis)
   - item for different diffractometer geometries.
   - UB matrix computation.
     - busing & Levy with 2 reflections
     - simplex computation with more than 2 reflections using the GSL
       library.
     - Eulerians angles to pre-orientate your sample.
   - Crystal lattice affinement
     - with more than 2 reflections you can select which parameter must
       be fitted.
   - Pseudoaxes
     - psi, eulerians, q, ...
** Conventions
   In all this document the next convention will be used to describe
   the diffractometers geometries.
   - right handed convention for all the angles.
   - direct space orthogonal base.
   - description of the diffractometer geometries is done with all
     axes values set to zero.
** Diffraction
*** the crystal

    A periodic crystal is the association of a pattern and a lattice. The
    pattern is located at each points of the lattice node. Positions of
    those nodes are given by:

    \begin{displaymath}
    R_{uvw}=u\cdot\vec{a}+v\cdot\vec{b}+w\cdot\vec{c}
    \end{displaymath}

    $\vec{a}$, $\vec{b}$, $\vec{c}$ are the former vector of a base of the
    space. =u=, =v=, =w= are integrers. The pattern contain atomes
    associated to each lattice node. the purpose of diffraction is to study
    the interaction of this crystal (pattern+lattice) with X-rays.

    #+CAPTION: Crystal direct lattice.
    [[./figures/crystal.png]]

    this lattice is defined by $\vec{a}$, $\vec{b}$, $\vec{c}$ vectors, and
    the angles $\alpha$, $\beta$, $\gamma$. In general cases this lattice is
    not othonormal.

    Nevertheless to compute the interaction of this real space lattice and
    the X-Rays, it is convenient to define another lattice called reciprocal
    lattice defined like this:

    \begin{eqnarray*}
    \vec{a}^{\star} & = & \tau\frac{\vec{b}\wedge\vec{c}}{\vec{a}\cdot(\vec{b}\wedge\vec{c})}\\
    \vec{b}^{\star} & = & \tau\frac{\vec{c}\wedge\vec{a}}{\vec{b}\cdot(\vec{c}\wedge\vec{a})}\\
    \vec{c}^{\star} & = & \tau\frac{\vec{a}\wedge\vec{b}}{\vec{c}\cdot(\vec{a}\wedge\vec{b})}
    \end{eqnarray*}

    $\tau=2\pi$ or $\tau=1$ depending on the conventions.

    It is then possible to define thoses orthogonal properties:

    \begin{eqnarray*}
    \vec{a}^{\star}\cdot\vec{a}=\tau & \vec{b}^{\star}\cdot\vec{a}=0    & \vec{c}^{\star}\cdot\vec{a}=0\\
    \vec{a}^{\star}\cdot\vec{b}=0    & \vec{b}^{\star}\cdot\vec{b}=\tau & \vec{c}^{\star}\cdot\vec{b}=0\\
    \vec{a}^{\star}\cdot\vec{c}=0    & \vec{b}^{\star}\cdot\vec{c}=0    & \vec{c}^{\star}\cdot\vec{c}=\tau
    \end{eqnarray*}

    This reciprocal space lattice allow to write in a simpler form the
    interaction between the crystal and the X-Rays. We often only know about
    $\vec{a}$, $\vec{b}$, $\vec{c}$ vectors and the angles $\alpha$,
    $\beta$, $\gamma$. Using the previous equations reciprocal, we can
    compute the reciprocal lattice this way:


    \begin{eqnarray*}
    a^{\star} & = & \frac{\sin\alpha}{aD}\\
    b^{\star} & = & \frac{\sin\beta}{bD}\\
    c^{\star} & = & \frac{\sin\gamma}{cD}
    \end{eqnarray*}

    where

    \begin{displaymath}
    D=\sqrt{1-\cos^{2}\alpha-\cos^{2}\beta-\cos^{2}\gamma+2\cos\alpha\cos\beta\cos\gamma}
    \end{displaymath}

    To compute the angles between the reciprocal space vectors, it is once
    again possible to use the previous equations reciprocal to obtain the
    sinus and cosinus of the angles $\alpha^\star$, $\beta^\star$ et
    $\gamma^\star$:

    \begin{eqnarray*}
    \cos\alpha^{\star}=\frac{\cos\beta\cos\gamma-\cos\alpha}{\sin\beta\sin\gamma} & \, & \sin\alpha^{\star}=\frac{D}{\sin\beta\sin\gamma} \\
    \cos\beta^{\star}=\frac{\cos\gamma\cos\alpha-\cos\beta}{\sin\gamma\sin\alpha} & \, & \sin\beta^{\star}=\frac{D}{\sin\gamma\sin\alpha}\\
    \cos\gamma^{\star}=\frac{\cos\alpha\cos\beta-\cos\gamma}{\sin\alpha\sin\beta} & \, & \sin\gamma^{\star}=\frac{D}{\sin\alpha\sin\beta}
    \end{eqnarray*}

    the volume of the lattice can be compute this way:

    \begin{displaymath}
    V = abcD
    \end{displaymath}

    or

    \begin{displaymath}
    V = \vec{a} \dot (\vec{b} \wedge \vec{c}) = \vec{b} \dot (\vec{c} \wedge \vec{a}) = \vec{c} \dot (\vec{a} \wedge \vec{b})
    \end{displaymath}


*** Diffraction

    Let the incomming X-rays beam whose wave vector is $\vec{k_{i}}$,
    $|k_{i}|=\tau/\lambda$ where $\lambda$ is the wavelength of the signal.
    The $\vec{k_{d}}$ vector wavelength of the diffracted beam. There is
    diffusion if the diffusion vector $\vec{q}$ can be expressed as follows:

    \begin{displaymath}
    \vec{q}=\vec{k_{d}}-\vec{k_{i}}=h.\vec{a}^{*}+k.\vec{b}^{*}+l.\vec{c}^{*}
    \end{displaymath}

    where $(h,k,l)\in\mathbb{N}^{3}$ and $(h,k,l)\neq(0,0,0)$. Thoses
    indices $(h,k,l)$ are named Miller indices.

    Another way of looking at things has been given by Bragg and that famous
    relationship:

    \begin{displaymath}
    n\lambda=2d\sin\theta
    \end{displaymath}

    where $d$ is the inter-plan distance and $n \in \mathbb{N}$.

    The diffusion accure for a unique $\theta$ angle. Then we got $\vec{q}$
    perpendicular to the diffraction plan.

    The Ewald construction allow to represent this diffraction in the
    reciprocal space.

*** Quaternions
**** Properties

     The quaternions will be used to discribe the diffractometers geometries.
     Thoses quaternions can represent 3D rotations. There is different way to
     describe then like complex numbers.

     \begin{displaymath}
     q=a+bi+cj+dk
     \end{displaymath}

     or

     \begin{displaymath}
     q=[a,\vec{v}]
     \end{displaymath}

     To compute the quaternion's norm, we can proceed like for complex
     numbers

     \begin{displaymath}
     \lvert q \rvert = \sqrt{a{{}^2}+b{{}^2}+c{{}^2}+d{{}^2}}
     \end{displaymath}

     Its conjugate is :

     \begin{displaymath}
     q^{*}=[a,-\vec{u}]=a-bi-cj-dk
     \end{displaymath}

**** Operations

     The difference with the complexnumber algebre is about
     non-commutativity.

     \begin{displaymath}
     qp \neq pq
     \end{displaymath}

     \begin{displaymath}
     \begin{bmatrix}
     ~ & 1 & i  & j  & k \cr
     1 & 1 & i  & j  & k \cr
     i & i & -1 & k  & -j \cr
     j & j & -k & -1 & i \cr
     k & k & j  & -i & -1
     \end{bmatrix}
     \end{displaymath}

     The product of two quaternions can be express by the Grassman product
     Grassman product. So for two quaternions $p$ and $q$:

     \begin{align*}
     q &= a+\vec{u} = a+bi+cj+dk\\
     p &= t+\vec{v} = t+xi+yj+zk
     \end{align*}

     we got

     \begin{displaymath}
     pq = at - \vec{u} \cdot \vec{v} + a \vec{v} + t \vec{u} + \vec{v} \times \vec{u}
     \end{displaymath}

     or equivalent

     \begin{displaymath}
     pq = (at - bx - cy - dz) + (bt + ax + cz - dy) i + (ct + ay + dx - bz) j + (dt + az + by - cx) k
     \end{displaymath}

**** 3D rotations

     L'ensemble des quaternions unitaires (leur norme est égale à 1) est le
     groupe qui représente les rotations dans l'espace 3D. Si on a un vecteur
     unitaire $\vec{u}$ et un angle de rotation $\theta$ alors le quaternion
     $[\cos\frac{\theta}{2},\sin\frac{\theta}{2}\vec{u]}$ représente la
     rotation de $\theta$ autour de l'axe $\vec{u}$ dans le sens
     trigonométrique. Nous allons donc utiliser ces quaternions unitaires
     pour représenter les mouvements du diffractomètre.

     Alors que dans le plan 2D une simple multiplication entre un nombre
     complex et le nombre $e^{i\theta}$ permet de calculer simplement la
     rotation d'angle $\theta$ autour de l'origine, dans l'espace 3D
     l'expression équivalente est:

     \begin{displaymath}
     z'=qzq^{-1}
     \end{displaymath}

     où $q$ est le quaternion de norme 1 représentant la rotation dans
     l'espace et $z$ le quaternion représentant le vecteur qui subit la
     rotation (sa partie réelle est nulle).

     Dans le cas des quaternions de norme 1, il est très facile de calculer
     $q^{-1}$. En effet l'inverse d'une rotation d'angle $\theta$ est la
     rotation d'angle $-\theta$. On a donc directement:

     \begin{displaymath}
     q^{-1}=[\cos\frac{-\theta}{2},\sin\frac{-\theta}{2}\vec{u}]=[\cos\frac{\theta}{2},-\sin\frac{\theta}{2}\vec{u}]=q^{*}
     \end{displaymath}

     Le passage aux matrices de rotation se fait par la formule suivante
     $q\rightarrow M$.

     \begin{displaymath}
     \begin{bmatrix}
     a{{}^2}+b{{}^2}-c{{}^2}-d{{}^2} & 2bc-2ad & 2ac+2bd\\
     2ad+2bc & a{{}^2}-b{{}^2}+c{{}^2}-d{{}^2} & 2cd-2ab\\
     2bd-2ac & 2ab+2cd & a{{}^2}-b{{}^2}-c{{}^2}+d{{}^2}
     \end{bmatrix}
     \end{displaymath}

     La composition de rotation se fait simplement en multipliant les
     quaternions entre eux. Si l'on à $q$

** Modes de fonctionnement
** Equations fondamentales

   Le problème que nous devons résoudre est de calculer pour une famille de
   plan $(h,k,l)$ donné, les angles de rotation du diffractomètre qui
   permettent de le mettre en condition de diffraction. Il faut donc
   exprimer les relations mathématiques qui lient les différents angles
   entre eux lorsque la condition de Bragg est vérifiée. L'équation
   fondamentale est la suivante:

   \begin{align*}
   \left(\prod_{i}S_{i}\right)\cdot U\cdot B\cdot\vec{h} & =\left(\prod_{j}D_{j}-I\right)\cdot\vec{k_{i}}\\
   R\cdot U\cdot B\cdot\vec{h} & =\vec{Q}
   \end{align*}

   ou $\vec{h}$ est le vecteur $(h,k,l)$, $\vec{k_{i}}$ est le vecteur
   incident, $S_{i}$ les matrices de rotations des mouvements liés à
   l'échantillon, $D_{j}$ les matrices de rotation des mouvements liés au
   détecteur, $I$ la matrice identité, $U$ la matrice d'orientation du
   cristal par rapport au repère de l'axe sur lequel ce dernier est monté
   et $B$ la matrice de passage d'un repère non orthonormé ( celui du
   crystal réciproque) à un repère orthonormé.

*** Calcule de B

    Si l'on connaît les paramètres cristallins du cristal étudié, il est
    très simple de calculer $B$:

    \begin{displaymath}
    B=
    \begin{bmatrix}
    a^{\star} & b^{\star}\cos\gamma^{\star} & c^{\star}\cos\beta^{\star}\\
    0 & b^{\star}\sin\gamma^{\star} & -c^{\star}\sin\beta^{\star}\cos\alpha\\
    0 & 0 & 1/c
    \end{bmatrix}
    \end{displaymath}

*** Calcule de U

    Il existe plusieurs façons de calculer $U$. Busing et Levy en a proposé
    plusieurs. Nous allons présenter celle qui nécessite la mesure de
    seulement deux réflections ainsi que la connaissance des paramètres
    cristallins. Cette façon de calculer la matrice d'orientation $U$, peut
    être généralisée à n'importe quel diffractomètre pour peu que la
    description des axes de rotation permette d'obtenir la matrice de
    rotation de la machine $R$ et le vecteur de diffusion $\vec{Q}$.

    Il est également possible de calculer $U$ sans la connaîssance des
    paramètres cristallins. il faut alors faire un affinement des
    paramètres. Cela revient à minimiser une fonction. Nous allons utiliser
    la méthode du simplex pour trouver ce minimum et donc ajuster l'ensemble
    des paramètres cristallins ainsi que la matrice d'orientation.

*** Algorithme de Busing Levy

    L'idée est de se placer dans le repère de l'axe sur lequel est monté
    l'échantillon. On mesure deux réflections $(\vec{h}_{1},\vec{h}_{2})$
    ainsi que leurs angles associés. Cela nous permet de calculer $R$ et
    $\vec{Q}$ pour chacune de ces reflections. nous avons alors ce système:

    \begin{eqnarray*}
    U\cdot B\cdot\vec{h}_{1} & = & \tilde{R}_{1}\cdot\vec{Q}_{1}\\
    U\cdot B\cdot\vec{h}_{2} & = & \tilde{R}_{2}\cdot\vec{Q}_{2}
    \end{eqnarray*}

    De façon à calculer facilement $U$, il est intéressant de définir deux
    trièdres orthonormé $T_{\vec{h}}$ et $T_{\vec{Q}}$ à partir des vecteurs
    $(B\vec{h}_{1},B\vec{h}_{2})$ et
    $(\tilde{R}_{1}\vec{Q}_{1},\tilde{R}_{2}\vec{Q}_{2})$. On a alors très
    simplement:

    \begin{displaymath}
    U \cdot T_{\vec{h}} = T_{\vec{Q}}
    \end{displaymath}

    Et donc

    \begin{displaymath}
    U = T_{\vec{Q}} \cdot \tilde{T}_{\vec{h}}
    \end{displaymath}

*** Affinement par la méthode du simplex

    Dans ce cas nous ne connaissons pas la matrice $B$, il faut donc mesurer
    plus que deux réflections pour ajuster les 9 paramètres. Six paramètres
    pour le crystal et trois pour la matrice d'orientation $U$. Les trois
    paramètres qui permennt de representer $U$ sont en fait les angles
    d'euler. il faut donc être en mesure de passer d'une représentation
    eulérien à cette matrice :math::U et réciproquement.

    \begin{displaymath}
    U = X \cdot Y \cdot Z
    \end{displaymath}

    où $X$ est la matrice rotation suivant l'axe Ox et le premier angle
    d'Euler, $Y$ la matrice de rotation suivant l'axe Oy et le deuxième
    angle d'Euler et $Z$ la matrice du troisième angle d'Euler pour l'axe
    Oz.

    #+ATTR_HTML: class="center"
    | $X$        | $Y$        | $Z$        |
    | <10>       | <10>       | <10>       |
    | $\begin{bmatrix} 1 & 0 & 0\\ 0 & A & -B\\ 0 & B & A \end{bmatrix}$ | $\begin{bmatrix}C & 0 & D\\0 & 1 & 0\\-D & 0 & C\end{bmatrix}$ | $\begin{bmatrix}E & -F & 0\\F & E & 0\\0 & 0 & 1\end{bmatrix}$ |

    et donc:

    \begin{displaymath}
    U=
    \begin{bmatrix}
    CE & -CF & D\\
    BDE+AF & -BDF+AE & -BC\\
    -ADE+BF & ADF+BE & AC
    \end{bmatrix}
    \end{displaymath}

    Il est donc facile de passer des angles d'Euler à la matrice
    d'orientation.

    Il faut maintenant faire la transformation inverse de la matrice $U$
    vers les angles d'euler.

* PseudoAxes
  This section describe the calculations done by the library for the
  different kind of pseudo axes.
** Eulerians to Kappa angles

   1st solution

   \begin{eqnarray*}
   \kappa_\omega & = & \omega - p + \frac{\pi}{2} \\
   \kappa & = & 2 \arcsin\left(\frac{\sin\frac{\chi}{2}}{\sin\alpha}\right) \\
   \kappa_\phi & = &  \phi - p - \frac{\pi}{2}
   \end{eqnarray*}

   or 2nd one

   \begin{eqnarray*}
   \kappa_\omega & = & \omega - p - \frac{\pi}{2} \\
   \kappa & = & -2 \arcsin\left(\frac{\sin\frac{\chi}{2}}{\sin\alpha}\right) \\
   \kappa_\phi & = &  \phi - p + \frac{\pi}{2}
   \end{eqnarray*}

   where

   \begin{displaymath}
   p = \arcsin\left(\frac{\tan\frac{\chi}{2}}{\tan\alpha}\right)
   \end{displaymath}

   and $\alpha$ is the angle of the kappa axis with the $\vec{y}$ axis.

** Kappa to Eulerians angles

   1st solution

   \begin{eqnarray*}
   \omega & = & \kappa_\omega + p - \frac{\pi}{2} \\
   \chi   & = & 2 \arcsin\left(\sin\frac{\kappa}{2} \sin\alpha\right) \\
   \phi   & = & \kappa_\phi + p + \frac{\pi}{2}
   \end{eqnarray*}

   or 2nd one

   \begin{eqnarray*}
   \omega & = & \kappa_\omega + p + \frac{\pi}{2} \\
   \chi   & = & -2 \arcsin\left(\sin\frac{\kappa}{2} \sin\alpha\right) \\
   \phi   & = & \kappa_\phi + p - \frac{\pi}{2}
   \end{eqnarray*}

   where

   \begin{displaymath}
   p = \arctan\left(\tan\frac{\kappa}{2} \cos\alpha\right)
   \end{displaymath}

   #+CAPTION: $\omega = 0$, $\chi = 0$, $\phi = 0$, 1st solution
   [[./figures/e2k_1.png]]

   #+CAPTION: $\omega = 0$, $\chi = 0$, $\phi = 0$, 2nd solution
   [[./figures/e2k_2.png]]

   #+CAPTION: $\omega = 0$, $\chi = 90$, $\phi = 0$, 1st solution
   [[./figures/e2k_3.png]]

   #+CAPTION: $\omega = 0$, $\chi = 90$, $\phi = 0$, 2nd solution
   [[./figures/e2k_4.png]]

** Qper and Qpar
   [[./figures/qper_qpar.png]]

   this pseudo axis engine compute the perpendicular
   ($\left|\left|\vec{Q_\text{per}}\right|\right|$) and parallel
   ($\left|\left|\vec{Q_\text{par}}\right|\right|$) contribution of
   $\vec{Q}$ relatively to the surface of the sample defined by the
   $\vec{n}$ vector.

   \begin{eqnarray*}
   \vec{q} & = & \vec{k_\text{f}} - \vec{k_\text{i}} \\
   \vec{q} & = & \vec{q_\text{per}} + \vec{q_\text{par}} \\
   \vec{q_\text{per}} & = & \frac{\vec{q} \cdot \vec{n}}{\left|\left|\vec{n}\right|\right|} \frac{\vec{n}}{\left|\left|\vec{n}\right|\right|}
   \end{eqnarray*}
* Diffractometers
  #+BEGIN_QUOTE
  *warning*

  This section is automatically generating by introspecting the hkl library.
  #+END_QUOTE

#+BEGIN_SRC python :exports results :results value raw
  from gi.repository import Hkl

  def bold(l):
      return ["\"*" + _ + "*\"" for _ in l]

  def level(indent=1, s=None):
      return "  "*indent + s

  diffractometers = Hkl.factories().iterkeys()

  output = ''
  for diffractometer in sorted(diffractometers):
      factory = Hkl.factories()[diffractometer]
      output += "** " + diffractometer + "\n\n"
      detector = Hkl.Detector.factory_new(Hkl.DetectorType(0))
      sample = Hkl.Sample.new("toto")
      geometry = factory.create_new_geometry()
      engines = factory.create_new_engine_list()
      engines.init(geometry, detector, sample)

      output += "*** Axes: \n"
      for axis in geometry.axis_names_get():
          axis_v = geometry.axis_get(axis).axis_v_get().data
          output += level(2, "+ \"*" + axis + "*\": rotation around the *" + repr(axis_v) + "* axis\n")

      output += "*** Engines: \n"
      for engine in engines.engines_get():
          output += "**** \"*" + engine.name_get() + "*\":\n\n"
          output += level(3, "* pseudo axes:\n")
          for pseudo in engine.pseudo_axis_names_get():
              p = engine.pseudo_axis_get(pseudo)
              description = p.description_get()
              output += level(4, "* \"*" + pseudo + "*\" : " + description + '\n\n')
          output += "\n"
          for mode in engine.modes_names_get():
              output += level(3, "+ mode: \"*" + mode + "*\"\n")
              engine.current_mode_set(mode)
              axes_r = engine.axis_names_get(Hkl.EngineAxisNamesGet.READ)
              axes_w = engine.axis_names_get(Hkl.EngineAxisNamesGet.WRITE)
              output += level(4, "+ axes (read) : " + ", ".join(bold(axes_r)) + "\n")
              output += level(4, "+ axes (write): " + ", ".join(bold(axes_w)) + "\n")
              parameters = engine.parameters_names_get()
              output += level(4, "+ parameters: ")
              if parameters:
                  output += "\n"
                  for parameter in parameters:
                      p = engine.parameter_get(parameter)
                      description = p.description_get()
                      value = p.value_get(Hkl.UnitEnum.USER)
                      output += level(5, "+ *" + parameter + "* [" + str(value) + "]: " + description + "\n")
              else:
                  output += "No parameter\n"

  return output
#+END_SRC
* Developpement
** Getting hkl

   To get hkl, you can download the last stable version from sourceforge or
   if you want the latest development version use
   [[http://git.or.cz/][git]] or
   [[http://code.google.com/p/msysgit/downloads/list][msysgit]] on windows
   system and do:

   #+BEGIN_SRC sh
git clone git://repo.or.cz/hkl.git
   #+END_SRC

   or:

   #+BEGIN_SRC sh
    git clone http://repo.or.cz/r/hkl.git (slower)
   #+END_SRC

   then checkout the next branch like this:

   #+BEGIN_SRC sh
    cd hkl
    git checkout -b next origin/next
   #+END_SRC

** Building hkl

   To build hkl you need [[http://www.python.org][Python 2.3+]] the
   [[http://www.gnu.org/software/gsl/][GNU Scientific Library 1.12]] and
   [[https://developer.gnome.org/glib/][GLib-2.0 >= 2.3.4]]:

   #+BEGIN_SRC sh
    ./configure --disable-gui
    make
    sudo make install
   #+END_SRC

   you can also build a GUI interfaces which use
   [[http://www.gtk.org][gtk]]:

   #+BEGIN_SRC sh
    ./configure
    make
    sudo make install
   #+END_SRC

   optionnaly you can build an experimental /libhkl3d/ library (no public
   API for now) which is used by the GUI to display and compute
   diffractometer collisions (only the /K6C/ model). To build it you need
   also [[https://projects.gnome.org/gtkglext/][gtkglext]] and
   [[http://bulletphysics.org/wordpress/][bullet 2.82]]:

   #+BEGIN_SRC sh
    ./configure --enable-hkl3d
    make
    sudo make install
   #+END_SRC

   if you want to work on the documentation you need the extra

   - [[http://www.gtk.org/gtk-doc/][gtk-doc]] for the api
   - [[http://sphinx.pocoo.org/][sphinx]] for the html and latex doc.
   - [[http://asymptote.sourceforge.net/][asymptote]] for the figures
   - [[http://www.gnu.org/software/emacs/][emacs]] the well known editor
   - [[https://github.com/emacsmirror/htmlize][htmlize]] used to highlight the source code
   - [[http://orgmode.org][org-mode]] litteral programming

   On Debian/Ubuntu you just need to install

   #+BEGIN_SRC sh
    sudo apt-get install emacs dvipng emacs-goodies-el org-mode
   #+END_SRC

   #+BEGIN_SRC sh
    ./configure --enable-gtk-doc
    make
    make html
#+END_SRC

   nevertheless if you do not want to build the documentation you can do:

   #+BEGIN_SRC sh
   ./configure --disable-hkl-doc
   #+END_SRC

** Hacking hkl
*** Bug reporting

    You can find the bug tracker here
    [[https://bugs.debian.org/cgi-bin/pkgreport.cgi?repeatmerged=no&src=hkl][libhkl]]

-  Debian/Ubuntu:

   #+BEGIN_SRC sh
       reportbug hkl
   #+END_SRC

-  Other OS

   You just need to send an [[mailto:submit@bugs.debian.org?subject=%20My%20problem%20with%20hkl...&body=Package:%20hkl%0AVersion:%20@VERSION@%0A%0AI%20found%20this%20problem%20in%20hkl][email]]

*** Providing patchs

    you can send your patch to [[picca@synchrotron-soleil.fr][Picca
    Frédéric-Emmanuel]] using =git=

    Here a minimalist exemple of the workflow to prepare and send a patch
    for hkl. Suppose you wan to add a new feature to hkl create first a new
    branch from the next one:

    #+BEGIN_SRC sh
    git checkout -b my-next next
    #+END_SRC

    hack, hack:

    #+BEGIN_SRC sh
    git commit -a
    #+END_SRC

    more hacks:

    #+BEGIN_SRC sh
    git commit -a
    #+END_SRC

    now that your new feature is ready for a review, you can send by email
    your work using git format-patch:

    #+BEGIN_SRC sh
    git format-patch origin/next
    #+END_SRC

    and send generated files ~0001\_xxx~, ~0002\_xxx~, ... to the author.

** Howto's
*** Add a diffractometer
    To add a new diffractometer, you just need to copy the
    ~hkl/hkl-engine-template.c~ into
    ~hkl/hkl-engine-INSTITUT-BEAMLINE-INSTRUMENT.c~ where you replace
    the upper case with the appropriate values.

    The template file is compiled during the build process to ensure
    that it is always valid.

    Then you just need to follow the instruction found in the
    template. If you need some precision about the process, do not
    hesitate to contact the main author.

    do not forgot also to add this new file into ~hkl/Makefile.am~
    with other diffractometers in the hkl_c_sources variable (please
    keep the alphabetic order).
*** Work on the documentation
    The documentation system is written with [[http://orgmode.org/][org-mode]], and the [[http://orgmode.org/worg/org-contrib/babel/][babel]]
    extension which allow to introspect the library and generate part
    of the doc using the hkl library. Python code is executed during
    the build process to generate the Diffractometer section of the
    documentation. To work on the doc and test the embedded python
    code it is necessary to setup a few environment variables and
    start emacs with the right LD_LIBRARY_PATH. In order to simplify
    the process a make target was written. You just need to type:
    #+BEGIN_SRC sh
      cd Documentation
      make editdoc
    #+END_SRC
    and start to contribute.

    If you do not have emacs, you can nevertheless contribute by
    editing the ~Documentation/hkl.org.in~ file which is text only.

    The most expected contributions for now are:
    * english correctness
    * a nicer css
* Bindings

  The hkl library use the gobject-introspection to provide automatic
  binding for a few languages.

** Python

   hkl computation:

   has you can see there is 4 available solutions.

   let's compute an hkl trajectory and select the first solution.

   if we look at the 3 other solutions we can see that there is a problem
   of continuity at the begining of the trajectory.

   hey what's happend with theses solutions ! let's look closely to real
   numbers. the last column is the distance to the diffractometer current
   position. This distance is for now express like this:

   $\sum_{axes} \left|\text{current position} - \text{target position}\right|$

   #+BEGIN_EXAMPLE
    [0.0, 119.99999999999999, 0.0, -90.0, 0.0, 59.99999999999999] 0.0
    [0.0, -119.99999999999999, 0.0, -90.0, 0.0, -59.99999999999999] 6.28318530718
    [0.0, -60.00000000000005, 0.0, 90.0, 0.0, 59.99999999999999] 6.28318530718
    [0.0, 60.00000000000001, 0.0, 90.0, 0.0, -59.99999999999999] 6.28318530718

    [0.0, 117.7665607657826, 7.456826294401656, -92.39856410531434, 0.0, 60.33024982425957] 0.216753826612
    [0.0, -57.436310940366894, -7.456826294401656, 92.39856418853617, 0.0, 60.33024982425957] 6.41621345188
    [0.0, 62.2334392342174, -7.456826294401656, 92.39856410531434, 0.0, -60.33024982425957] 6.42197739723
    [0.0, -122.5636890596331, 7.456826294401656, -92.3985641885362, 0.0, -60.33024982425957] 6.50570308205

    [0.0, 115.89125602137928, 14.781064139466098, -94.7660423112577, 0.0, 61.314597086440706] 0.219062698235
    [0.0, -125.42334103772737, 14.781064139466098, -94.7660427050904, 0.0, -61.314597086440706] 6.53671995288
    [0.0, -54.57665896227262, -14.781064139466098, 94.76604270509038, 0.0, 61.314597086440706] 6.67989976726
    [0.0, 64.10874397862072, -14.781064139466098, 94.7660423112577, 0.0, -61.314597086440706] 6.71437170098

    [0.0, 114.39338605351007, 21.85448296702796, -97.074145033719, 0.0, 62.93506298693471] 0.218163667981
    [0.0, -128.54167683157993, 21.85448296702796, -97.07414574435087, 0.0, -62.93506298693471] 6.59846359365
    [0.0, -51.45832316842005, -21.85448296702796, 97.07414574435087, 0.0, 62.93506298693471] 6.93673746356
    [0.0, 65.60661394648993, -21.85448296702796, 97.074145033719, 0.0, -62.93506298693471] 7.03385205725

    [0.0, 113.28316795475283, 28.583837575232764, -99.29953499008337, 0.0, 65.16540747008955] 0.21459359225
    [0.0, -131.88223933078322, 28.583837575232764, -99.29953638594702, 0.0, -65.16540747008955] 6.69038531388
    [0.0, -48.11776066921677, -28.583837575232764, 99.29953638594702, 0.0, 65.16540747008955] 7.18296350386
    [0.0, 66.71683204524717, -28.583837575232764, 99.29953499008337, 0.0, -65.16540747008955] 7.37556986959

    [0.0, 112.56286877075006, 34.90573305321372, -101.42496979586187, 0.0, 67.97568017857415] 0.209053830457
    [0.0, -135.4128111996365, 34.90573305321372, -101.42497263302461, 0.0, -67.97568017857415] 6.81174779784
    [0.0, -44.58718880036348, -34.90573305321372, 101.4249726330246, 0.0, 67.97568017857415] 7.41581162393
    [0.0, 67.43713122924994, -34.90573305321372, 101.42496979586187, 0.0, -67.97568017857415] 7.7353201851

    [0.0, 112.2291126083182, 40.78594007247402, -103.43941832567457, 0.0, 71.33706722449408] 0.202280147961
    [0.0, -139.10795451001587, 40.78594007247402, -103.43942357602316, 0.0, -71.33706722449408] 6.96173845391
    [0.0, -40.89204548998411, -40.78594007247402, 103.43942357602312, 0.0, 71.33706722449408] 7.63358787543
    [0.0, 67.7708873916818, -40.78594007247402, 103.43941832567457, 0.0, -71.33706722449408] 8.10986069093

    [0.0, 112.27578927291766, 46.214916130901734, -105.33741042812996, 0.0, 75.22640762217479] 0.196576175748
    [0.0, -142.95061850160724, 46.214916130901734, -105.3374188005596, 0.0, -75.22640762217479] 7.13962155618
    [0.0, -37.04938149839278, -46.214916130901734, 105.33741880055959, 0.0, 75.22640762217479] 7.83557762281
    [0.0, 67.72421072708234, -46.214916130901734, 105.33741042812996, 0.0, -75.22640762217479] 8.49706672677

    [0.0, 112.697137434232, 51.201667684695856, -107.11797492933192, 0.0, 79.63023536264535] 0.202327153157
    [0.0, -146.9330984641471, 51.201667684695856, -107.11798610058318, 0.0, -79.63023536264535] 7.34491897177
    [0.0, -33.0669015358529, -51.201667684695856, 107.11798610058317, 0.0, 79.63023536264535] 8.02185610877
    [0.0, 67.30286256576798, -51.201667684695856, 107.11797492933192, 0.0, -79.63023536264535] 8.89597005568

    [0.0, 113.49085964586432, 55.76762791023837, -108.78347437395287, 0.0, 84.54867879242364] 0.208455586312
    [0.0, -151.05782007465257, 55.76762791023837, -108.78348605483542, 0.0, -84.54867879242364] 7.57761473366
    [0.0, -28.942179925347414, -55.76762791023837, 108.78348605483538, 0.0, 84.54867879242364] 8.19307323084
    [0.0, 66.50914035413568, -55.76762791023837, 108.78347437395287, 0.0, -84.54867879242364] 9.30675279514

    [0.0, 114.6614608037443, 59.941489465646214, -110.3385360479293, 0.0, 90.00000081324956] 0.215562935229
    [0.0, -155.33854118146962, 59.941489465646214, -110.33854432979601, 0.0, -89.99999918675044] 7.83839602383
    [0.0, -24.661458818530395, -59.941489465646214, 110.33854432979601, 0.0, 90.00000081324956] 8.3502621071
    [0.0, 65.3385391962557, -59.941489465646214, 110.3385360479293, 0.0, -89.99999918675044] 9.7307712883
   #+END_EXAMPLE

   as you can see for the first point of the trajectory, the 2nd, 3rd and
   4th solutions have identical distances to the current position of the
   diffractometer so they are un-ordered:

   #+BEGIN_EXAMPLE
    [0.0, 119.99999999999999, 0.0, -90.0, 0.0, 59.99999999999999] 0.0
    [0.0, -119.99999999999999, 0.0, -90.0, 0.0, -59.99999999999999] 6.28318530718
    [0.0, -60.00000000000005, 0.0, 90.0, 0.0, 59.99999999999999] 6.28318530718
    [0.0, 60.00000000000001, 0.0, 90.0, 0.0, -59.99999999999999] 6.28318530718
   #+END_EXAMPLE

   then the problem arise with the second and third solution. you can see a
   sort of reorganisation of the solution. 2 -> 3, 3 -> 4 and 4 -> 2 then
   the order will stick unchanged until the end of the trajectory. this is
   because the distance is computed relatively to the current position of
   the diffractometer.:

   #+BEGIN_EXAMPLE
    [0.0, 117.7665607657826, 7.456826294401656, -92.39856410531434, 0.0, 60.33024982425957] 0.216753826612
    [0.0, -57.436310940366894, -7.456826294401656, 92.39856418853617, 0.0, 60.33024982425957] 6.41621345188
    [0.0, 62.2334392342174, -7.456826294401656, 92.39856410531434, 0.0, -60.33024982425957] 6.42197739723
    [0.0, -122.5636890596331, 7.456826294401656, -92.3985641885362, 0.0, -60.33024982425957] 6.50570308205

    [0.0, 115.89125602137928, 14.781064139466098, -94.7660423112577, 0.0, 61.314597086440706] 0.219062698235
    [0.0, -125.42334103772737, 14.781064139466098, -94.7660427050904, 0.0, -61.314597086440706] 6.53671995288
    [0.0, -54.57665896227262, -14.781064139466098, 94.76604270509038, 0.0, 61.314597086440706] 6.67989976726
    [0.0, 64.10874397862072, -14.781064139466098, 94.7660423112577, 0.0, -61.314597086440706] 6.71437170098
   #+END_EXAMPLE

   #+BEGIN_QUOTE
   *warning*

   when you compute a trajectory, start from a valid position (the
   starting point must be the real first point of your trajectory) then
   use only the closest solution for the next points of the trajectory.
   (first solution of the geometries list)
   #+END_QUOTE
* Releases
** @VERSION@
*** DONE =HklLattice= add an =hkl_lattice_volume_get=
#+BEGIN_SRC c
  volume = hkl_lattice_volume_get(lattice);
#+END_SRC
*** DONE =HklEngine= "nrj, sample, ...  dependencies" <2015-03-24 mar.>
    Add the =hkl_engine_dependencies_get= method which return if the
    =HklEngine= depends of the axes, the energy, or the sample. the
    possible values are stored in the =HklEngineDependencies= enum.

#+BEGIN_SRC c
  dependencies = hkl_engine_dependencies_get(engine);
  if (dependencies & HKL_ENGINE_DEPENDENCIES_ENERGY) {
          ...
  }
  if (dependencies & HKL_ENGINE_DEPENDENCIES_SAMPLE) {
          ...
  }
  ...
#+END_SRC
* Todo
** hkl
*** TODO [#A] [0/3] HklEngine "read_only"
    * [ ] "alpha" incidence angle
    * [ ] "beta" emergence angle
    * [ ] "tth" the real 2*theta
*** TODO [0/2] PetraIII
**** TODO computation problem
     Dear Teresa,

     Using the prruptest.txt ubmatrix I see that the value of psi is
     offset by 45 degrees. I expect it to be 0 degrees when azimuth
     reference vector is 0 0 1 that is along the beam. See below
     thereturned numbers. This might have to do with the definition of
     the beam axis in the controller.  Otherwise now when I change
     reference vector by 90 degrees the computed value is changed by
     90 degrees. That is a progress. Can you contact Frederic and ask
     him about this ?

     Best regards,

     Sonia

     See below
     p09/door/haspp09.01 [9]: setaz 1 0 0

     p09/door/haspp09.01 [10]: wh

     Engine: hkl

     Mode: psi_constant_vertical

     H K L =    0.00000   3.00605  -0.00000
     Ref   =    1.00000   0.00000   0.00000
     Azimuth (Psi - calculated) =  -45.00005
     Azimuth (Psi - set) =  0.00000
     Wavelength =  2.07957

     Delta       Theta          Chi         Phi         Mu       Gamma
     45.77575    22.88783     90.00000   182.85400    0.00000    -0.00000

     p09/door/haspp09.01 [11]: setaz 0 0 1

     p09/door/haspp09.01 [12]: wh

     Engine: hkl

     Mode: psi_constant_vertical

     H K L =    0.00000   3.00605  -0.00000
     Ref   =    0.00000   0.00000   1.00000
     Azimuth (Psi - calculated) =  -135.00005
     Azimuth (Psi - set) =  0.00000
     Wavelength =  2.07957

     Delta       Theta          Chi         Phi         Mu       Gamma
     45.77575    22.88783     90.00000   182.85400    0.00000    -0.00000

     where:

     Azimuth (Psi - calculated) is the value of the pseudomotor psi.
     Azimuth (Psi - set) is the value set in the parameter psi of the current mode.

   Hi Frederic,

   This is the UB matrix:

   Best regards,

   Sonia

   Created at 2015-01-21 12:35

   Crystal    prruptest

   Wavelength 2.07957463938

   A 8.03656 B 8.03656 C 8.03656
   Alpha 90.0 Beta 90.0 Gamma 90.0

   R0 0 0.0 1.0 0.0 0 1 0.0 14.8979 90.0 182.854 0.0 29.7959
   R1 1 1.0 0.0 1.0 0 1 0.0 14.8979 0.0 182.854 0.0 29.7959

   Mode psi_constant_vertical

   PsiRef 0.0 0.0 1.0

   U00 -0.580 U01 0.000 U02 0.525
   U10 0.000 U11 0.782 U12 -0.000
   U20 -0.525 U21 -0.000 U22 -0.580

   Ux 179.999952315 Uy 42.14605 Uz -179.999932647

   SaveDirectory /home/p09user/crystals/

**** TODO another question
     J'ai un probleme avec la position que le controlleur calcule avec la
     matrice UB que nous t'avons envoye.
     See sequence of emails echanges avec Teresa.

     >>>> I am at 0 3.00605 0 with phi -182 and psi calculated is -135
     >>>> When I freeze psi at -135  and type ca 0 3.00605 0 the controller
     >> should return to me the positions at which I am. But no he tells me
     that I
     >> have to go to 178 degrees in  phi that is turning by 360 degrees.

     Est-ce un probleme avec la trajectoire selectionnee ?
     Est-ce qu'il est possible de definir des cut-points comme dans spec avec
     ta librairie ?
*** TODO [2/4] HklParameter
    - [X] method to use min/max to check for the validity
    - [X] add a method to get the axis_v and quaternion of the HklAxis
      this method will return NULL if this is not relevant.
      hkl_parameter_axis_v_get and hkl_parameter_quaternion_get
    - [ ] degenerated an axis is degenerated if its position have no
      effect on the HklPseudoAxis calculus. Add a degenerated member
      to the axis. that way it would be possible to check a posteriori
      for this degenerescencence.
    - [ ] Add a description for each parameters.
      This will help for the documentation and the gui.
*** TODO HklGeometryList different method to help select a solution.
    this select solution can depend on the geometry
    for example the kappa axis must be in one side of the plane.
*** TODO add a fit on the Hklaxis offsets.
*** TODO API to put a detector and a sample on the Geometry.
*** TODO HklSample
**** TODO [#B] unit test: hkl_sample_affine.
     Check this:
     lattice=1.540000;1.540000;1.540000;90.000000;90.000000;90.000000;0;0;0;0;0;0
     uxuyuz=0.000000;0.000000;0.000000
     reflection=1.540000;0.159010;1.256718;0.796660;1;0.000000;0.000000;0.000000;0.000000;0.000000
     reflection=1.540000;0.206208;0.342357;-0.080346;1;0.000000;0.000000;0.000000;0.000000;0.000000
     reflection=1.540000;0.206208;0.342357;-0.080346;1;0.000000;0.000000;0.000000;0.000000;0.000000

     A,  B, C, Alpha,  Beta, Gamma, Ux, Uy, Uy:
     17764892.133, 5793679.092, 15733785.198,  179.997,  179.999,452408725.23,  -575727594.04,  -1913661011.01 (affine) 1rst finetness

     all the reflections are non collinear the affine method should
     warn the user about this.
*** TODO HklEngine "zone"
*** TODO HklEngine "custom"
    for now this pseudoaxis let you select the axis you
    want to use for the computation.
*** TODO create a macro to help compare two real the right way
    fabs(a-b) < epsilon * max(1, abs(a), abs(b))
*** TODO add an hkl_sample_set_lattice_unit()
*** TODO SOLEIL SIXS
**** DONE find the right solutions.				      :zaxis:
     The cosinus and sinus properties are not enough to find the solution expected by the users.
     The idea is to use the Ewalds construction to generate a valid solution from the first one
     obtain numerically. The basic idea is to rotate the hkl vector around the last axis of the
     sample holder until it intersect again the Ewalds sphere. Then we just need to fit the
     detector position. This way the solution can be entirely generic (not geometry specific).
     Nevertheless it is necessary to propose this only for the hkl pseudo axes. I will add this
     special feature in the Mode. So it will be possible to add thoses special cases easily.
**** TODO Add the DEP diffractometer geometry
     This diffractometer is a Newport one based on the kappa 6 circles ones.
     But instead of a kappa head, they use an Hexapod head.
     This head can be put horizontally or vertically.
*** TODO generalisation of the z-axis hkl solver
    first we need the degenerated member of the Axis. thaht way it could be possible
    to find the last non degenerated axis for the detector fit.
*** TODO investigate the prigo geometry.
*** TODO augeas/elektra for the plugin configure part.
*** TODO logging
**** TODO [1/2] add in a few methods.
     + [X] hkl_pseudo_axes_values_set
     + [ ] hkl_sample_affine
**** TODO gir logging
     It would be nice to generate the library logging using the .gir
     information. So instead of writing the logging code for each
     method, it would be better to have a generic method for this
     purpose.
**** TODO parsable logging information.
     A parsable logging format would help to setup some re-play unit
     test. This way it could help during the developpement process
     (modification of the hkl internals) to be confident that
     computation are ok.
*** TODO performances
    Investigate [[http://liboil.freedesktop.org/wiki/][liboil]] to speed calculation (in HklVector, HklMatrix
    and HklQuaternion)
** documentation
*** TODO [1/6] rewrite documentation in org-mode
    - [-] embedding code into the org file
      - [-] [1/4] python
	- [X] auto generation of the diffractometer descriptions
	- [ ] trajectories explanations
	- [ ] trajectories tests.
	- [ ] unit tests output ?
      - [ ] asymptote
    - [X] need to check if templates could be generated using the hkl
      python binding for all diffractometer geometries.
    - [ ] need to add a description for the diffractometer, the mode, the parameters.
    - [ ] need a nice css for the generated doc.
    - [ ] check if org-info.js could be usefull
    - [ ] add documentation explaining the sector-cuts a la hkl
** [0/3] gui
   - [ ] change the color of fitparameter cells if they differ from
     the current sample values
   - [ ] check if a [[https://github.com/jonathanslenders/python-prompt-toolkit/tree/master/examples/tutorial][REPL]] could be integrated to provide an autocad
      like interface.
   - [ ] add tooltips using hkl_parameter_description_get for the
     pseudo axes and the mode parameters.
** hkl3d
*** TODO add a method to find the 3D models in the right directories.

** packaging
*** TODO add a .spec file for rpm generation.
